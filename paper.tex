%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}

\begin{document}

\conferenceinfo{Haskell Symposium 2012}{13th September, Copenhagen.}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{A draft paper to be submitted to Haskell Symposium 2012}
\preprintfooter{TBD: short description of paper}   % 'preprint' option specified.

\title{Behavior Driven Development in Haskell}
%\subtitle{Subtitle Text, if any}

\authorinfo{Simon HENGEL}
           {TBD: Affiliation}
           {TBD: Email}
\authorinfo{Trystan SPANGLER}
           {TBD: Affiliation}
           {TBD: Email}
\authorinfo{Kazuhiko YAMAMOTO}
           {IIJ Innovation Institute Inc.}
           {kazu@iij.ad.jp}

\maketitle

\begin{abstract}

TBD: Asbtract will be written at the final moment.

State the problem.

Say why itâ€™s an interesting problem.

Say what your solution achieves.

Say what follows from your solution.

\end{abstract}

\category{TBD:CR-number}{subcategory}{third-level}

\terms
TBD

\keywords
software design, documentation, automatic test

\section{Introduction}

%%%% Describe the problem.

One of the best features of Haskell is its strong type system, 
which ensures no type errors in programs if they can be complied.
Thanks to this, programs written in Haskell have less bugs
than other programming languages which do not provide such strong type systems.

Unfortunately, the strong type system of Haskell does not guarantee
no value errors.
Haskellers is, however, apt to rely on the strong type system too much.
They tend to write less test programs than programmers of other
programming languages.

TBD: we need evidence to support above.

This also means that typical usage examples cannot be found from test programs.
We agree that type signatures are good abstract document but
there are many functions whose behaviors cannot be guessed from
their names and type signatures.

Why do we dislike to write test programs?
It is probably because writing test programs is not fun.
To encourage Haskellers to write more test programs
to detect value errors,
we need a scheme to make writing test programs more interesting.

For this purpose,
we brought design methods from other programming language communities and
integrated them with a Haskell-original test method.
In particular, we introduced {\tt doctest} and
integrated with QuickCheck. 
We also implemented {\tt hspec} with QuickCheck enabled.

In our method, design specification takes role of documentation for users and
is used as test cases by its developer. 
This method would motivate Haskellers
bacause it has a kill-three-birds-with-one-stone aspect.

%The purpose of this paper is to encourage Haskllers to write documentation, which can be used for testing, in their libraries.

%%%% State your contributions.

The contribution of this paper is as follows:

\begin{itemize}
\item Introduced {\tt doctest} from Python community to Haskell community
and integrated it with QuickCheck (Section XXX)
\item Introduced {\tt hspec} from Ruby community to Haskell community and
integrated it with QuickCheck (Section XXX)
\item Show best current practice of design/documentation/tests (Section XXX)
\end{itemize}

\section{Terminology}

The definitions of words used in this paper is as follows:

\begin{description}
\item[unit test] tests for individual programs or libraries.
\item[example] Typical usage of functions.
\item[property] Invariants which functions have.
\item[behavior] How do functions behave for users. Behavior can be shown by using both example and property.
\item[design] TBD
\item[documentation] Explanation of functions.
\end{description}

\section{Observation}

We insist that examples and properties, which are useful for users, should be
documented.
So, let us first observe Haddock, the documentation system of Haskell. Haddock defines annotation syntax in Haskell's comment.

\subsection{Example annotation}

We can specify examples with the annotation syntax {\tt >>>}.
The following is an example of how to use the {\tt length} function
for lists.

\begin{quote}
\begin{verbatim}
> length []
0
\end{verbatim}
\end{quote}

\noindent We can write this by copy-and-pasting from an interpreter.
It's worth explaining that we can specify operation sequences:

\begin{quote}
\begin{verbatim}
> writeFile "tmpfile" "Hello"
> readFile "tmpfile"
"Hello"
\end{verbatim}
\end{quote}

\noindent But example annotations are useful for users but 
it is not used as test case from the developer point of view (before we implemented {\tt doctest}).

\subsection{Property annotation}

The {\tt container} packages has equation properties:

\begin{quote}
\begin{verbatim}
>>> Data.Map.null (empty) == True
\end{verbatim}
\end{quote}

It is written in code blocks ({\tt >}).
This cannot be used as test case.

Equation property is tested 100 times.

Quickcheck property should be able to be specified.

To our experience, it is not difficult to find properties for pure functions.
We believe that Haskellers should show properties of pure functions
in documentation.

\subsection{Internal documentation}

not useful for users

\section{Solution}

FIRST convey the idea.

\subsection{Tests suitable with doctest}

\subsection{Tests suitable with hspec}

\subsection{Integrating multiple test suites}

\section{Best current practice}

undefined.

The authors are not fundamentalist.
If functions to be defined are simple enough,
we might implement them first withtout signatures.
And their signatures can be automatically
inserted by IDE (like ghc-mod) later
if Haskell compilers can infer correctly.
Also, we can cut and paste typical examples and their results
from Haskell interpreters to their document.

\section{Implementation}

\subsection{doctest}

how to handle error cases.

\subsection{doctest and QuickCheck}

\subsection{hspec}

\section{Related work}

literate programming.

hunit.

test-framework.

smallCheck.

And others?

\section{Conclusion}

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.

\acks

We would like to thank
Nick Smallbone for having improved QuickCheck so that boolean property is tested
just once.
We are grateful to David Waern and Simon Marlow
for introducing the property syntax to Haddock.


% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\end{document}
