% vim: tw=70
%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{url}
\usepackage{alltt}

\begin{document}

\conferenceinfo{Haskell Symposium 2012}{13th September, Copenhagen.}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

% These are ignored, unless 'preprint' option specified.
\titlebanner{A draft paper to be submitted to Haskell Symposium 2012}
\preprintfooter{TBD: short description of paper}

\title{Behavior Driven Development in Haskell}
%\subtitle{Subtitle Text, if any}

\authorinfo{Kazuhiko YAMAMOTO}
           {IIJ Innovation Institute Inc.}
           {kazu@iij.ad.jp}
\authorinfo{Simon HENGEL}
           {TBD}
           {sol@typeful.net}
\authorinfo{Markus KLINIK}
           {Elektrobit Automotive GmbH}
           {markus.klinik@elektrobit.com}

\maketitle

\begin{abstract}
We observed that several widely used Haskell libraries do not have
tests.
Test code assists developers in maintaining correctness when extending
software, and shows users how an API is supposed to be used.
To ease the production and enhance the value of test code, we advocate
behavior driven development with two tools:
Doctest for user documentation and
Hspec for code documentation.
Our approach can be used for design, documentation and automated
testing.  We hope that this motivates Haskell programmers to write
more and better tests.
\end{abstract}

\category{D.2.2}{Software Engineering}{Testing tools}

\terms Languages, Design, Verification

\keywords Doctest, Haddock, Hspec, QuickCheck

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:introduction}

%%%% Describe the problem.
\begin{itemize}
    \item ref to appendix
\end{itemize}

Haskell~\cite{haskell} has a strong type system, which ensures that most type errors are
detected at compile time rather than runtime.  Thanks to this, we assume that
programs written in Haskell have less bugs than programs written in programming
languages that do not provide such a strong type system.

Unfortunately, the type system of Haskell does not always guarantee
correct semantics.
For example, it does not ensure that division by zero does not occur.
An other example is, that instances of {\tt Monoid} \emph{should} be
monoids in the mathematical sense, but the type system does not
enforce this.  It is the programmers responsibility to ensure that
instance definitions \emph{behave} as \emph{expected}.  Hence
automated testing is useful.

However, some widely used Haskell libraries do not have automated
tests.  For example, the Haskell Platform 2011.4.0.0 contains 23
packages, not counting the 19 core libraries that come with GHC.  Only
8 of them have a test suite, 5 provide example code, and 10 have
neither tests nor examples.  A lack of tests is not only a quality and
maintainability issue.  It also is a lack of documentation.  Tests
document how code is supposed to be used, and tests document the
behavior of code.

In other programming language communities, behavior driven development
(BDD) is getting much attention, and is slowly replacing test driven
development (TDD).  TDD is an iterative style of software development
where the developer first writes a few test cases, then implements the
software in the simplest possible way which makes the test cases pass.
That could mean yielding a constant value at first.  Subsequently,
more test cases are written to require more details and drive the
implementation closer to the desired goal.  Rinse and repeat.

BDD includes TDD, amongst other software development methodologies,
but with a terminology and mindset shifted towards
specification instead of testing.
In BDD, specifications can be used for
automated testing.
BDD is meant to be an enjoyable experience for the developer.
Compared to TDD it provides a much nicer syntax that
makes tests very easy to read.  And like TDD it puts emphasis on
test automation, to take workload off the shoulders of
developers.
BDD-style TDD has been pioneered by
RSpec~\cite{rspec}.  In this paper, we explore how to apply the TDD
aspect of BDD to Haskell.


In BDD, all behavior should be documented, together with some testable
\emph{evidence} for that behavior.  Most existing BDD tools only use
\emph{code examples} as evidence for behavior.
Hspec\footnote{%
http://hackage.haskell.org/package/hspec},
a BDD tool for Haskell inspired by RSpec, supports
both code examples and \emph{properties} as evidence.
It can verify examples and test properties, and it can create an
informal specification document from that.

Hspec is thus useful for \emph{code documentation}, but we observed that parts
of a specification can be useful as user documentation. To that end,
Python's {\tt doctest} module~\cite{doctest} is of interest for us.
It is not commonly described as a BDD tool, but we think it can be
used for BDD.
There is a Haskell version called Doctest\footnote{%
http://hackage.haskell.org/package/doctest}, which is integrated with Haddock~\cite{haddock},
the standard documentation mechanism for Haskell.
It extracts \emph{interactive examples} from Haddock comments and
verifies them automatically.

We show how to use Doctest and Hspec in combination, to design,
document and test Haskell code.  Both, Doctest and Hspec are missing
some features.  So we extend them as needed.  In particular, our
contributions are:

\begin{itemize}
\item
    We originally implemented Haskell's version of Doctest, and
    extended Haddock's markup to support examples, back in 2010
    (Section~\ref{sec:haddock} and Section~\ref{sec:doctest})
\item
    We added support for QuickCheck properties to Doctest, and extended
    Haddock's markup to support properties
    (Section~\ref{sec:user-doc} and Section~\ref{sec:doctest})

\item
    We introduce a set of combinators to express expectations about
    code examples for use with Hspec
    (Section~\ref{sec:code-doc} and Section~\ref{sec:hspec-comb})

\item
    We improve automatic discovery support for Doctest and Hspec
    (Section~\ref{sec:solution-discovery} and Section~\ref{sec:implementation-discovery})

\item
    We show best current practices of BDD in Haskell, using Doctest
    and Hspec (Section~\ref{sec:best-current-practice})

\end{itemize}

\noindent Our approach can be used for design, documentation and
automated testing.  We hope that this motivates Haskell programmers to write
more and better tests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terminology}

The definitions of words used in this paper is as follows:

\begin{description}

\item[example]
    An example shows how a function is used.  It is either a \emph{code
    example} in the form of an HUnit test case; or an \emph{interactive
    example}, given as a short GHCi session.

\item[expectation]
    Expectations are used to express the expected outcome of a code
    example.  They serve the same purpose as \emph{assertions} in
    traditional unit testing frameworks, but use a different
    terminology.

\item[property]
    A property is something that is testable with
    QuickCheck~\cite{quickcheck}.

\item[behavior]
    Behavior means an invariant of a function.  We use an informal description
    to refer to a particular behavior, e.g.  "sorts a list" or "launches
    missiles when run".

\item[evidence]
    Evidence provides some confidence, that a function exhibits a
    certain behavior.  In Haskell we use examples and properties as
    evidence.

\item[spec]
    TBD: BDD terminology for test suite.
\end{description}


\begin{quote}
    \emph TBD: Check, terminology for consistency, and remove
    unnecessary terminology (if any).  This has to be done as one of
    the last steps.
\end{quote}

\begin{description}
\item[developer]
    A programmer who develops a library.

\item[user]
    A programmer who uses a library.


\item[user documentation]
    Explanation of functions for users.
\item[code documentation]
    Explanation of functions for developers.

\item[non-quantified property]
    Property which does not take parameters.

\item[quantified property]
    Property which takes parameters.

\end{description}

%\noindent The word ``behavior'' might be associated with ``imperative
%action''.  Since pure functions of Haskell are static, this word might
%be improper for Haskell.  However, this word is already used in the
%Haskell community~\cite{typeclassopedia}.  So, we use ``behavior''
%instead of defining terminology in this paper.

%\begin{quote}
%    sol: We e.g. say ill-behaved Monoid instance.  So is
%    ``behavior'' really a ``bad'' word?  But I agree that some people in
%    the community might associated it with something imperative.
%
%    kazu: ``behavior'' sounded strange at least to me at the first time.
%    We alreay supported this word with typeclassopedia. So, I think
%    this paragraph is completed. Should we replace ``is associated'' with
%    ``might be associated''?
%
%    sol: @kazu, this was primarily meant for @mkl as reference.
%
%    One might also argue that ``should'' is not very mathematical, but
%    it is common language when we talk about mathematics.  E.g. Brent
%    Yorgey uses both ``should'' and ``behave'' a lot in the
%    Typeclassopedia (e.g. ``\ldots {\tt Alternative} should satisfy
%    the monoid laws\ldots'')
%\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
\label{sec:problem}
\begin{itemize}
    \item TBD: use \emph{code documentation} somewhere here.
\end{itemize}

BDD tools can be used to document the behavior of a system in a way that
is similar to a specification.  All facets of the system should be
described with evidence, including every possible corner case.

As we discussed in Section~\ref{sec:introduction},
We think that some evidence is useful as user documentation.
But there is also evidence, that is not
useful as user documentation.  E.g. that a particular \texttt{Monoid}
instance is a monoid in the mathematical sense is self-evident.

We propose to use Doctest and Haddock for evidence that is useful as
user documentation, and Hspec for evidence that is not useful as user
documentation.  The following subsections discuss problems that we
have to solve before we can do this.

\subsection{Haddock}
\label{sec:doctest-haddock}

Haddock has markup support for code blocks, and code blocks are widely used
to include properties and examples into documentation\footnote{
See e.g. the documentation of
{\tt containers},
{\tt filepath},
{\tt bytestring} or
{\tt text}.}.
Here is an example from the {\tt filepath} package.

\begin{quote}
\small
\begin{verbatim}
-- | Does the given filename have an extension?
--
-- > null (takeExtension x) == not (hasExtension x)
hasExtension :: FilePath -> Bool
hasExtension = any isExtSeparator . takeFileName
\end{verbatim}
\end{quote}

\noindent Though code blocks in Haddock comments are a useful feature,
we still think that this particular usage has problems.  The code
block contains a property.  And it would be useful to have a tool that
automatically extracts and tests the property.
But writing such a tool is hard, because it is not easy to decide
whether the code block is a property, an example, or something else.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hspec}

If we have evidence that does not fit into the user documentation, but
would rather be part of a design document, we use Hspec\footnote{%
Hspec was originally implemented by Trystan Spangler, and is now
maintained by one of the authors.}.

Hspec provides an EDSL for defining specs.  A \emph{spec} organizes evidence
in a tree structure (or a forest, to be accurate), and is defined
with \texttt{it} and \texttt{describe}.

Here is an example that specifies some behavior of the {\tt reverse}
function.

\begin{quote}
\small
\begin{verbatim}
import Test.Hspec.Monadic

main :: IO ()
main = hspec spec

spec :: Spec
spec = do
  describe "reverse" $ do
    it "reverses a list" $
      assertEqual "" [3, 2, 1] (reverse [1, 2, 3])

    it "gives the original list, if applied twice" $
      property $ \xs ->
        (reverse . reverse) xs == (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent The {\tt it} function combines a text description for a
behavior and some evidence (a code example or a property) into a spec.
Code examples can be arbitrary HUnit test cases\footnote{%
Wrapping the test case with HUnit's {\tt TestCase} constructor is not
necessary.}.  If a property is used as evidence, it must be wrapped
with QuickCheck's {\tt property} function.

The \texttt{describe} function combines a list of specs into a larger spec.
% It can be used to organize a spec as a tree.
% Internally, a \texttt{Writer} is used to build up specs in a monadic way.
A spec can be run with the \texttt{hspec} function.  When a spec is
run, all evidence is tested, and a report is generated.  Behavior with
evidence that does not hold is marked as {\tt FAILED} in the
report.

%%%%%%%%%%%%%%%%
% \subsubsection{Hspec does not provide a mechanism for expectations}
BDD frameworks use ``should'' or ``must'' instead of
``assert'' to express expectations.  Here is an example that uses
RSpec.

\begin{quote}
\small
\begin{verbatim}
[1, 2, 3].reverse.should eq([3, 2, 1])
\end{verbatim}
\end{quote}


\noindent Hspec does not yet provide a mechanism to express
\emph{expectations} with that terminology.  The developer has to use
HUnit assertions instead.

%%%%%%%%%%%%%%%%
% \subsubsection{Hspec provides no mechanism to expect exceptions}
Moreover RSpec provides a mechanism to expect exceptions.  It is used
like this:

\begin{quote}
\small
\begin{verbatim}
expect {launch_missiles}.to raise_error
\end{verbatim}
\end{quote}

\noindent Neither Hspec nor HUnit provide a convenient equivalent.

\subsection{Automatic discovery of specs}
\label{sec:problem-discovery}

It is a common convention to have one spec file for each source file.
To run all specs for a given project together, it is necessary to
combine all the specs from all spec files into a single spec.  For
example, if we have three modules, \verb|Foo|, \verb|Foo.Bar| and
\verb|Baz|, and corresponding specs in \verb|FooSpec|,
\verb|Foo.BarSpec| and \verb|BazSpec|, we are required to write the
following boilerplate:

\begin{quote}
\small
\begin{verbatim}
import Test.Hspec.Monadic

import qualified FooSpec
import qualified Foo.BarSpec
import qualified BazSpec

main :: IO ()
main = hspec $ do
  describe "Foo"     FooSpec.spec
  describe "Foo.Bar" Foo.BarSpec.spec
  describe "Baz"     BazSpec.spec
\end{verbatim}
\end{quote}

\noindent This is error prone, and neither challenging nor
interesting.  So it should be automated.  But Hspec does not provide a
solution for generating such \emph{test drivers}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Problem summary}

Here is a summary of the problems:

\begin{itemize}
\item
    There is no way to automatically test examples and properties
    contained in user documentation.
\item
    For code documentation,
    Hspec does not provide combinators to express expectations in
    BDD terminology.
\item
    There is no facility that automatically finds and combines all
    specs of a project.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Solution}

As we explained in Section~\ref{sec:problem},
we use Doctest for user documentation and Hspec for code documentation.
The following subsections explain two extensions to Haddock's markup.
Subsequently, combinators for expectations, that can be used with
Hspec, are introduced.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{User documentation}
\label{sec:user-doc}



Evidence that is useful as user documentation should be included in
Haddock comments.  For this purpose, we propose the following:

\begin{itemize}
\item Add markup syntax for interactive examples to Haddock
\item Add markup syntax for properties to Haddock
\item
    Implement a tool, similar to Python's {\tt doctest} module, that
    can verify examples and test properties in Haddock comments.
    The implementation is discussed in Section~\ref{sec:doctest}.

\end{itemize}

%%%%%%%%%%%%%%%%
\subsubsection{Markup for examples}

We introduce new Haddock markup for interactive examples.  A line
starting with a \emph{prompt} (``{\tt >>>}'') denotes an expression.
Lines following an expression denote the result of that expression.
Here is an example:

\begin{quote}
\small
\begin{verbatim}
-- |
-- >>> length []
-- 0
\end{verbatim}
\end{quote}

\noindent The result ends at the next empty line, or another prompt.
It is possible to specify example sequences:

\begin{quote}
\small
\begin{verbatim}
-- |
-- >>> writeFile "tmpfile" "Hello"
-- >>> readFile "tmpfile"
-- "Hello"
\end{verbatim}
\end{quote}

\noindent Result is defined by what GHCi prints to stdout and stderr
when evaluating the expression.  This, e.g. also allows to document
exceptions:

\begin{quote}
\small
\begin{verbatim}
-- |
-- >>> head []
-- *** Exception: Prelude.head: empty list
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%
\subsubsection{Markup for properties}
\label{sec:markup}

\noindent To specify properties, we also introduce new markup. A line
starting with ``{\tt prop>}'' indicates a property.

\begin{quote}
\small
\begin{verbatim}
-- |
-- prop> Data.Map.null empty == True
\end{verbatim}
\end{quote}

\noindent It is possible to quantify properties by using a
lambda expression. The property from Section~\ref{sec:doctest-haddock}
can be written as:

\begin{quote}
\small
\begin{alltt}
-- |
-- prop> \verb|\|x -> null (takeExtension x) == \(\hookleftarrow\)
               not (hasExtension x)
\end{alltt}
\end{quote}

\noindent The $\hookleftarrow$ symbol denotes line continuation.

GHCi's type defaulting~\cite{ghc-manual} applies to properties.  If a default type is
not suitable, explicit type-signatures can be used:

\begin{quote}
    TBD: @kazu, can you add this to the bib:
    \url{http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/interactive-evaluation.html}
\end{quote}

\begin{quote}
\small
\begin{verbatim}
-- |
-- prop> \xs -> sort xs == (sort . sort) (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent Since the lambda abstraction adds nothing to the
documentation, it can be omitted:

\begin{quote}
\small
\begin{verbatim}
-- |
-- prop> sort xs == (sort . sort) (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent We call such properties \emph{implicitly quantified}.  The
given property is implicitly quantified over {\tt xs}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Code documentation}
\label{sec:code-doc}

We propose the following extensions for Hspec to
describe evidence for developers.

%%%%%%%%%%%%%%%%
\subsubsection{Setting expectations}

We propose several combinators which can be used to set expectations
about the outcome of code examples.  These are built on top of HUnit:

\begin{quote}
\small
\begin{verbatim}
type Expectation = Assertion
\end{verbatim}
\end{quote}

\noindent A common expectation is, that a value should be equal to another
value:

\begin{quote}
\small
\begin{verbatim}
x `shouldBe` 23
\end{verbatim}
\end{quote}

\noindent This is just another name for HUnit's \texttt{@?=}
operator.  The type is:

\begin{quote}
\small
\begin{verbatim}
shouldBe :: (Show a, Eq a) => a -> a -> Expectation
\end{verbatim}
\end{quote}

\noindent Or we may expect that a value should satisfy some
predicate.

\begin{quote}
\small
\begin{verbatim}
x `shouldSatisfy` (< 23)
\end{verbatim}
\end{quote}

\noindent The value is required to be in the \texttt{Show} class, so that a
useful error message can be given when the predicate is not satisfied.

\begin{quote}
\small
\begin{verbatim}
shouldSatisfy :: Show a => a -> (a -> Bool)
  -> Expectation
\end{verbatim}
\end{quote}

\noindent Code examples are often used to provide evidence for {\tt
IO} actions, e.g.:

\begin{quote}
\small
\begin{verbatim}
launchMissiles >>=
  (`shouldBe` Left "not implemented")
\end{verbatim}
\end{quote}

\noindent So we propose a shortcut for this common use case:

\begin{quote}
\small
\begin{verbatim}
launchMissiles `shouldReturn` Left "not implemented"
\end{verbatim}
\end{quote}

\noindent Where \verb|shouldReturn| has the following type:

\begin{quote}
\small
\begin{verbatim}
shouldReturn :: (Show a, Eq a) => IO a -> a
  -> Expectation
\end{verbatim}
\end{quote}


%%%%%%%%%%%%%%%%
\subsubsection{Expecting exceptions}
\label{sec:expacting-exceptions}

HUnit does not provide a convenient mechanism to state that an action
should throw an exception.  So we propose a combinator for that.

\begin{quote}
\small
\begin{verbatim}
shouldThrow :: Exception e => IO a -> (e -> Bool)
  -> Expectation
\end{verbatim}
\end{quote}

\noindent It takes an {\tt IO} action, and a predicate.  The predicate
servers two purposes.  It selects the type of the expected exception,
and constrains the value.  Here is an example:

\begin{quote}
\small
\begin{verbatim}
launchMissiles `shouldThrow` (== ExitFailure 1)
\end{verbatim}
\end{quote}

%\noindent And it can be used with predicates from {\tt
%System.IO.Error}, to require specific {\tt IOException}, e.g.  with
%{\tt isPermissionError}:
%
%\begin{quote}
%\small
%\begin{verbatim}
%launchMissiles `shouldThrow` isPermissionError
%\end{verbatim}
%\end{quote}

\noindent To make it more convenient to expect any exception of a
certain type, we provide type-restricted versions of {\tt (const
True)} for all standard exceptions, e.g.:

\begin{quote}
\small
\begin{verbatim}
anyArithException :: ArithException -> Bool
anyArithException = const True
\end{verbatim}
\end{quote}

\noindent Which can be used like this:

\begin{quote}
\small
\begin{verbatim}
evaluate (1 `div` 0) `shouldThrow` anyArithException
\end{verbatim}
\end{quote}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Automatic discovery of specs}
\label{sec:solution-discovery}

We want to automatically discover all specs of a project, so that we
can run them all together.  This requires to automatically generate
boilerplate code, similar to what is shown in
Section~\ref{sec:problem-discovery}.

We make creative use GHC's support for custom preprocessors for
that.  With our solution, the developer creates a test driver, that only
contains a single line:

\begin{quote}
\small
\begin{verbatim}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
\end{verbatim}
\end{quote}

\noindent This tells GHC to run a preprocessor, \verb|hspec-discover|, on the
source file.  \verb|hspec-discover| finds all specs for a project, and
generates a suitable test driver.

This approach relies on the following conventions:
\begin{enumerate}
    \item
        Spec files have to be placed into the same directory as the
        test driver, or into a subdirectory.
    \item
        The name of a spec file has to end in \verb|Spec.hs|, and the
        module name has to match the file name.
    \item
        Each spec file has to export a top-level binding \verb|spec|,
        of type \verb|Spec|.
\end{enumerate}

\noindent It would be possible to lift some of those requirements.
But we think they are reasonable conventions, anyway.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Haddock}
\label{sec:haddock}

We added markup support for interactive examples to Haddock, and it is
available since version 2.8.
We also added markup support for properties, which will be included in
a future release of Haddock.

\subsection{Doctest}
\label{sec:doctest}

Doctest uses the GHC API to extract properties and examples from
Haddock comments, and uses GHCi to test them.
Before testing, Doctest brings the module that contains the Haddock
comment from which the evidence was extracted into scope.

\subsubsection{Testing examples}

Verification of examples is done by
comparing the expected output given in the Haddock comment with the
actual output of GHCi.

Doctest reuses the same GHCi session for all examples.
Examples from the same Haddock comment are grouped together,
and share the same scope.
Doctest clears the scope with \verb|:reload| before it tests a new
example group.

\subsubsection{Testing properties}

QuickCheck is used to test properties.
Implicitly quantified properties need to be closed before they can be
tested.  This requires the following steps.
\begin{enumerate}
    \item
        Find all free variables of the property.
    \item
        Try to lookup each free variable in the module context.
    \item
        Close the property over all free variables, for which lookup
        failed.
\end{enumerate}

\noindent Here is the example from Section~\ref{sec:markup}:

\begin{quote}
\small
\begin{verbatim}
sort xs == (sort . sort) (xs :: [Int]))
\end{verbatim}
\end{quote}

\noindent Both \verb|xs| and \verb|sort| are free variables, but
\verb|sort| is bound by the module context.  So we need to close the
term over \verb|xs|.

\begin{quote}
\small
\begin{verbatim}
\xs -> sort xs == (sort . sort) (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent The implementation is fully functional, and it will be included in the
next release of Doctest.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Hspec combinators for expectations}
\label{sec:hspec-comb}

\noindent All combinators introduced in Section~\ref{sec:code-doc} have been
implemented.  They are available from Hackage\footnote{%
http://hackage.haskell.org/package/hspec-shouldbe},
and will be incorporated into a future
release of Hspec.
The implementation is straightforward, so we will not further discuss
it.

\subsection{Automatic discovery of specs}
\label{sec:implementation-discovery}

As discussed in Section~\ref{sec:solution-discovery}, we use a preprocessor to
automatically generate test drivers for Hspec.  GHC invokes the
preprocessor with three arguments:

\begin{description}
    \item[{\tt src}]
        -- path to the original source file\\
        A preprocessor usually does not
        look at the content of this file.  It is only provided, so
        that it can be used in error messages.
    \item[{\tt cur}]
        -- path to a file that holds the input for the preprocessor
    \item[{\tt dst}]
        -- a path, where the preprocessor should write it's result to
\end{description}


\noindent A typical preprocessor reads the content of {\tt cur},
processes it, and writes the result to {\tt dst}.  If something goes
wrong, it uses {\tt src} in error messages to refer to the source
file.

\verb|hspec-discover| ignores {\tt cur} altogether.  It uses the
directory component of {\tt src}, to find all files that are in the
same directory as the source file, or in any subdirectories.  It then generates
a test driver from all files that end in {\tt Spec.hs}.

A fully functional implementation is available from
Hackage\footnote{http://hackage.haskell.org/package/hspec-discover},
and it will be incorporated into a future release of Hspec.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Best current practices}
\label{sec:best-current-practice}

In this section we show how to do BDD in Haskell, how to reuse pieces
of specification, and how to use Doctest and Hspec in combination with
Cabal's test feature.

\subsection{Applying BDD to Haskell: An Example}
\label{sec:bcp-example}
This section shows how behavior driven development works in practice,
by means of the Fibonacci function.  Of course this is a very simple
example, but the method is also applicable to more sophisticated
situations where design decisions might not be as obvious as here.

We present a step-by-step refinement of a library, and a corresponding
spec.  Each line of code is only given once when introduced,
subsequent code fragments are incremental updates.

\subsubsection{Starting with a minimal implementation}

We start with the function's documentation, which gives a usage
example, together with the simplest possible implementation that makes
the example work.

\begin{quote}
\small
\begin{verbatim}
-- | Calculate Fibonacci numbers.
--
-- >>> fib 10
-- 55
fib :: Int -> Integer
fib = const 55
\end{verbatim}
\end{quote}

\noindent This first step might appear excessively trivial, but as of now we
already have made some choices with regard to the API of our library.
By giving a usage example, we were forced to think about which
arguments our function takes.  We can now run Doctest to verify that
the example works.

\begin{quote}
\small
\begin{verbatim}
$ doctest Fib.hs
Examples: 1  Tried: 1  Errors: 0  Failures: 0
\end{verbatim}
\end{quote}


\subsubsection{Getting it right}

Next, we add a specification that forces our function to actually
calculate Fibonacci numbers.
At this stage we do not worry about invalid input or performance.  We
are happy with an implementation that works for small non-negative
integers.

\begin{quote}
\small
\begin{verbatim}
newtype Small = Small Int
  deriving Show

instance Arbitrary Small where
  arbitrary = Small . (`mod` 10) <$> arbitrary

main = hspec spec

spec = do
  describe "fib" $ do
    it "calculates arbitrary Fibonacci numbers" $ do
      property $ \(Small n) ->
        fib n == fib (n + 2) - fib (n + 1)
\end{verbatim}
\end{quote}

\noindent This spec fails when we run it:

\begin{quote}
\small
\begin{verbatim}
$ runhaskell FibSpec.hs
fib
 - calculates arbitrary Fibonacci numbers FAILED [1]
\end{verbatim}
\end{quote}

\noindent So we add a working implementation:

\begin{quote}
\small
\begin{verbatim}
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
\end{verbatim}
\end{quote}

\noindent Both Doctest and Hspec report success now.


\subsubsection{Getting it fast}

Our implementation is quite inefficient, as made evident by this
specification:

\begin{quote}
\small
\begin{verbatim}
it "is efficient" $ do
  timeout 10000 (evaluate $ fib 32)
    `shouldReturn` Just 2178309
\end{verbatim}
\end{quote}

\noindent When we run it, hspec tells us:

\begin{quote}
\small
\begin{verbatim}
$ runhaskell FibSpec.hs
fib
 - calculates arbitrary Fibonacci numbers
 - is efficient FAILED [1]
\end{verbatim}
\end{quote}

\noindent And we respond with an efficient implementation:

\begin{quote}
\small
\begin{verbatim}
fib :: Int -> Integer
fib n = fibs !! n
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
\end{verbatim}
\end{quote}

\noindent With a much more efficient implementation at hand, we can
now adapt our definition of small non-negative integers, so that
a wider range of input values is tested:

\begin{quote}
\small
\begin{verbatim}
instance Arbitrary Small where
  arbitrary = Small . (`mod` 1000) <$> arbitrary
\end{verbatim}
\end{quote}


\subsubsection{Handling invalid input}

We have an implementation of the Fibonacci function
that calculates correct values for all non-negative integers.
But what about negative ones? Let's assume that we want our
implementation to throw an exception in this case. We would
specify it like this.

\begin{quote}
\small
\begin{verbatim}
it "throws ErrorCall on negative input" $ do
  evaluate (fib (-10)) `shouldThrow` anyErrorCall
\end{verbatim}
\end{quote}

\noindent Our implementation already fulfils this spec, so we are
fine.

\subsubsection{Dealing with specification changes}

At some point, we realize that throwing an exception on invalid input
is not suitable for our use-case.  Hence, we change the specification,
so that negative input values should result in zero.

\begin{quote}
\small
\begin{verbatim}
it "returns 0 on negative input" $ do
  fib (-10) `shouldBe` 0
\end{verbatim}
\end{quote}

\noindent Now our specification fails, so we adapt the implementation
accordingly.

\begin{quote}
\small
\begin{verbatim}
fib n | n < 0     = 0
      | otherwise = fibs !! n
\end{verbatim}
\end{quote}

\noindent It should be the case that fib returns 0 for all negative
numbers, so we state that in the specification:

\begin{quote}
\small
\begin{verbatim}
it "returns 0 on negative input" $ do
  property $ \n -> n < 0 ==>
    fib n == 0
\end{verbatim}
\end{quote}


\noindent Again, our implementation already fulfils that spec.

This concludes our example.  We have seen how to utilize
behavior driven development to incrementally build a small library.
We always extend or adapt the specification first, watch it fail,  and
then tighten the implementation.  The combinators {\tt shouldBe}, {\tt
shouldReturn} and {\tt shouldThrow} can be used to specify behavior of
functions in an intuitive, easy to read manner.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reusable pieces of specification}
\label{sec:reusable-specs}

RSpec provides an explicit mechanism to facilitate reuse of pieces of
specification~\cite{rspec}.
In Haskell we get reusability for free, it does not require any
explicit support from Hspec.
The following example illustrates this.
Here is a specification that documents that a list is a monoid:

\begin{quote}
\small
\begin{verbatim}
spec = do
  describe "List as a Monoid" $ do
    describe "mempty" $ do
      it "is a left identity" $ property $ \x ->
        mempty <> x == (x :: [Int])

      it "is a right identity" $ property $ \x ->
        x <> mempty == (x :: [Int])

    describe "<>" $ do
      it "is associative" $ property $ \x y z ->
        (x <> y) <> z == (x <> (y <> z) :: [Int])
\end{verbatim}
\end{quote}

\noindent It is possible to to make this specification reusable, by
abstracting over the type:

\begin{quote}
\small
\begin{verbatim}
shouldSatisfyMonoidLaws ::
  (Eq a, Show a, Monoid a, Arbitrary a) => a -> Spec
shouldSatisfyMonoidLaws t = do
  describe "mempty" $ do
    it "is a left identity" $ property $ \x ->
      mempty <> x == x `asTypeOf` t

    it "is a right identity" $ property $ \x ->
      x <> mempty == x `asTypeOf` t

  describe "<>" $ do
    it "is associative" $ property $ \x y z ->
      (x <> y) <> z == x <> (y <> z) `asTypeOf` t
\end{verbatim}
\end{quote}

\noindent This can be used to document and test arbitrary Monoid
instances.
The specification from above becomes:

\begin{quote}
\small
\begin{verbatim}
spec = do
  describe "List as a Monoid" $ do
    shouldSatisfyMonoidLaws (undefined :: [Int])
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cabal integration}

\noindent Cabal's test feature can be used to automatically run tests~\cite{cabal}.  A cabal
file can contain multiple test suites, so it is possible to define test suites
for Doctest and Hspec in the same cabal file.

As discussed in Section~\ref{sec:solution-discovery},
{\tt hspec-discover} can be used to automatically generate a test
driver for Hspec:

\begin{quote}
\small
\begin{verbatim}
-- file Spec.hs
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
\end{verbatim}
\end{quote}

\noindent A corresponding Cabal test suite section looks like this:

\begin{quote}
\small
\begin{verbatim}
test-suite spec
  type:          exitcode-stdio-1.0
  main-is:       Spec.hs
  build-depends: base, hspec
\end{verbatim}
\end{quote}

\noindent Doctest provides both, an executable and a library.  The library
exposes a function ``{\tt doctest}'' of type:


\begin{quote}
\small
\begin{verbatim}
doctest :: [String] -> IO ()
\end{verbatim}
\end{quote}

\noindent Doctest's own {\tt main} is simply:
\begin{quote}
\small
\begin{verbatim}
main = getArgs >>= doctest
\end{verbatim}
\end{quote}



\noindent Consequently, it is possible to create a custom executable
for a project, by passing all command-line arguments that are required
for that project to {\tt doctest}.  A simple example looks like this:

\begin{quote}
\small
\begin{verbatim}
-- file doctests.hs
import Test.DocTest
main = doctest ["--optghc=isrc", "src/Main.hs"]
\end{verbatim}
\end{quote}

\noindent And a corresponding Cabal test suite section like this:

\begin{quote}
\small
\begin{verbatim}
test-suite doctests
  type:          exitcode-stdio-1.0
  main-is:       doctests.hs
  build-depends: base, doctest
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Open problems and future work}

In Section~\ref{sec:reusable-specs}, we showed how to reuse pieces of
specification.  It would be possible and useful to write a library
that provides reusable pieces of specification, for many of Haskell's
standard classes (similar in purpose to {\tt
checkers}\footnote{http://hackage.haskell.org/package/checkers}).
This would provide a convenient mechanism for developers to document
and test that their instance definitions are well-behaved.

When Hspec finds failing evidence, it reports the corresponding
behavior to the developer.  It would be useful to include source
locations for failing evidence, so that the programmer can find the
corresponding spec immediately. Solving this with GHC requires
Template Haskell.  Extending GHC with a mechanism
similar to JHC's \verb|SRCLOC_ANNOTATE| pragma\footnote{%
http://repetae.net/computer/jhc/jhc.shtml} would allow to solve this
without Template Haskell.

Cucumber~\cite{cucumber} is a higher-level approach to BDD for Ruby, and
it is typically used in combination with RSpec.
It focuses on user stories, to assist the developer in delivering
value to the stakeholder.
There is nothing comparable to Cucumber for Haskell, yet.  And we think
it would be interesting to explore, whether it is possible to apply
Cucumber's approach to Haskell.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related work}

SmallCheck~\cite{smallcheck} is a tool for
automatic exhaustive testing up to a certain depth.
Both Doctest and Hspec do not have support for SmallCheck
at this moment.
Hspec's mechanism for evidence is extensible, and it would be easy to
add support for SmallCheck.

{\tt test-framework} is a library that allows TDD in Haskell, and it
has support for HUnit, QuickCheck and SmallCheck.
There is support for automatic test discovery that relies on naming
conventions for test functions\footnote{%
http://hackage.haskell.org/package/test-framework-th}.  It is
implemented with Template Haskell~\cite{template-haskell}, and it only
works within a single source file.  Automatic discovery across
multiple source files is not possible with a mechanism that is based
on Template Haskell, because Template Haskell can not generate import
statements\footnote{%
See http://hackage.haskell.org/trac/ghc/ticket/1475 }.

The {\tt testpack}\footnote{%
http://hackage.haskell.org/package/testpack}
package provides a combinator to expect exceptions,
similar to {\tt shouldThrow} from
Section~\ref{sec:expacting-exceptions}:

\begin{quote}
\small
\begin{verbatim}
assertRaises :: (Show a, Exception e, Show e, Eq e) =>
  String -> e -> IO a -> IO ()
\end{verbatim}
\end{quote}

\noindent But it has several shortcomings:
It only works for exceptions with an {\tt Eq} instance,
but several standard exceptions (most
prominently {\tt ErrorCall}) have no {\tt Eq} instance.
And it places an unnecessary {\tt Show} constraint on the
result of the {\tt IO} action, further limiting it's applicability.
It only allows to expect specific exception values, expecting
arbitrary exceptions of a certain type is not possible.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}


We showed how to apply behavior driven development to
Haskell.  We proposed to use Doctest for user documentation and Hspec
for code documentation. We extended Haddock's markup with support for
examples and properties.  And we implemented Doctest, which verifies
examples and tests properties in Haddock comments.
We added two missing features to Hspec: Combinators to express
expectations, and a mechanism for automatic discovery of specs.
And we showed how to reuse pieces of specification.
Our approach can be used for design, documentation and automated
testing.  We hope that this motivates Haskell programmers to write
more and better tests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\section{The final code from Section~\ref{sec:bcp-example}}
\label{sec:appendix-code}

\begin{quote}
\small
\begin{verbatim}
-- file Fib.hs
module Fib (fib) where

-- | Calculate Fibonacci numbers.
--
-- >>> fib 10
-- 55
fib :: Int -> Integer
fib n | n < 0     = 0
      | otherwise = fibs !! n

fibs = 0 : 1 : zipWith (+) fibs (tail fibs)


-- file FibSpec.hs
module FibSpec (main, spec) where

import Control.Applicative
import Control.Exception
import System.Timeout

import Test.QuickCheck
import Test.Hspec.ShouldBe

import Fib

-- small non-negative numbers
newtype Small = Small Int
  deriving Show

instance Arbitrary Small where
  arbitrary = Small . (`mod` 1000) <$> arbitrary

main = hspec spec

spec = do
  describe "fib" $ do
    it "calculates arbitrary Fibonacci numbers" $ do
      property $ \(Small n) ->
        fib n == fib (n + 2) - fib (n + 1)

    it "is efficient" $ do
      timeout 10000 (evaluate $ fib 32)
        `shouldReturn` Just 2178309

    it "returns 0 on negative input" $ do
      property $ \n -> n < 0 ==>
        fib n == 0
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\acks

We are grateful to David Waern, Haddock's maintainer, for reviewing and
accepting our patches to Haddock.
We would like to thank
Nick Smallbone for having improved QuickCheck so that
non-quantified properties are tested just once.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{refs}

\end{document}
