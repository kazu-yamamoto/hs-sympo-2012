%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}

\begin{document}

\conferenceinfo{Haskell Symposium 2012}{13th September, Copenhagen.}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{A draft paper to be submitted to Haskell Symposium 2012}
\preprintfooter{TBD: short description of paper}   % 'preprint' option specified.

\title{Behavior Driven Development in Haskell}
%\subtitle{Subtitle Text, if any}

\authorinfo{Simon HENGEL}
           {TBD: Affiliation}
           {TBD: Email}
\authorinfo{Trystan SPANGLER}
           {TBD: Affiliation}
           {TBD: Email}
\authorinfo{Kazuhiko YAMAMOTO}
           {IIJ Innovation Institute Inc.}
           {kazu@iij.ad.jp}

\maketitle

\begin{abstract}

TBD: Asbtract will be written at the final moment.

State the problem.

Say why itâ€™s an interesting problem.

Say what your solution achieves.

Say what follows from your solution.

\end{abstract}

\category{D.2.2}{Software Engineering}{Testing tools}

\terms Languages, Design, Verification

\keywords Haddock, QuickCheck, doctest, hspec

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

%%%% Describe the problem.

One of the best features of Haskell is its strong type system, 
which ensures no type errors in programs if they can be complied.
Thanks to this, programs written in Haskell have less bugs
than other programming languages which do not provide such strong type systems.

Unfortunately, the strong type system of Haskell does not guarantee
no value errors.
Haskellers is, however, apt to rely on the strong type system too much.
They tend to write less test programs than programmers of other
programming languages. TBD: we need evidence to support this.

This also means that typical usage examples cannot be found from test programs.
We agree that type signatures are good abstract document but
there are many functions whose behaviors cannot be guessed from
their names and type signatures.

Why do we dislike to write test programs?
It is probably because writing test programs is not fun.
To encourage Haskellers to write more test programs
to detect value errors,
we need a scheme to make writing test programs more interesting.

For this purpose,
we brought design methods from other programming language communities and
integrated them with a Haskell-original test method.
In particular, we introduced {\tt doctest} and
integrated with QuickCheck. 
We also implemented {\tt hspec} with QuickCheck enabled.

In our method, design specification takes role of documentation for users and
is used as test cases by its developer. 
This method would motivate Haskellers
bacause it has a kill-three-birds-with-one-stone aspect.

%The purpose of this paper is to encourage Haskllers to write documentation, which can be used for testing, in their libraries.

%%%% State your contributions.

The contribution of this paper is as follows:

\begin{itemize}
\item Introduced {\tt doctest} from Python community to Haskell community
and integrated it with QuickCheck (Section XXX)
\item Introduced {\tt hspec} from Ruby community to Haskell community and
integrated it with QuickCheck (Section XXX)
\item Show best current practice of design/documentation/tests (Section XXX)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terminology}

The definitions of words used in this paper is as follows:

\begin{description}
\item[unit test] tests for individual programs or libraries.
\item[example] Typical usage of functions.
\item[property] Invariants which functions have.
\item[behavior] How do functions behave for users. Behavior can be shown by using both example and property.
\item[design] TBD
\item[documentation] Explanation of functions.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Observation}

We insist that examples and properties, which are useful for users, should be
documented.
So, let us first observe Haddock, the documentation system of Haskell. Haddock defines annotation syntax in Haskell's comment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Example annotation}

We can specify examples with the annotation syntax {\tt >>>}.
The following is an example of how to use the {\tt length} function
for lists.

\begin{quote}
\begin{verbatim}
>>> length []
0
\end{verbatim}
\end{quote}

\noindent The first line starts with {\tt >>>} and an expression follows. The second line contains its result. We can write this by copy-and-pasting from an interpreter and modifying the prompt.
It's worth explaining that we can specify operation sequences:

\begin{quote}
\begin{verbatim}
>>> writeFile "tmpfile" "Hello"
>>> readFile "tmpfile"
"Hello"
\end{verbatim}
\end{quote}

\noindent Example annotations are useful for users but 
it is not used as test case from the developer point of view (before we implemented {\tt doctest}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Property annotation}

Haddock also provides code block annotations indicated with ({\tt >}).
For example, the {\tt container} packages has the following code block annotation:

\begin{quote}
\begin{verbatim}
> Data.Map.null (empty) == True
\end{verbatim}
\end{quote}

\noindent Some Haskellers like this kind of equations and dislike to write it with the example annotation as follows:

\begin{quote}
\begin{verbatim}
>>> Data.Map.null (empty)
True
\end{verbatim}
\end{quote}

We can see the equation as a no-parameter property for {\tt null} and {\tt empty} and
can say that there are potentially demands to show properties with Haddock annotation.
To our experience, it is not difficult to find properties for pure functions.
We believe that Haskellers should show properties of pure functions
in documentation.

But there is no annotation syntax to describe properties in Haddock.
Even if a prefix keyword for properties is defined, 
we have no agreement on how to describe parameterized properties: e.g. how to specify types of funcation parameters. And we don't have automatic test mechanism to use properties in documentation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Internal documentation}

There are some examples and properties which are not useful for users but useful for developers. One example is a corner case registered in a bug track system. TBD: setup-teardown. We don't have a mechanism to integrate design, documentation and tests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Solution}

To specify visible behavior, we propose to use {\tt doctest} integrated with QuickCheck. To describe internal behavior, we propose to use {\tt hspec} aslo integrated with QuickCheck.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Visible behavior}

To execute examples in haddock annotations, we introduced {\tt doctest} from Python community and implemented it in Haskell.

TBD: command and library. 
TBD: talk about exception.

To specify properties in haddock annotations, we propose a new syntax. In this paper, we use the {\tt prop>} prefix. We can write the no-parameter equation as follows:

\begin{quote}
\begin{verbatim}
prop> Data.Map.null (empty) == True
\end{verbatim}
\end{quote}

\noindent Of course, we allowed parameterized properties by
using closed lambda terms.
Type signatures can be specified for each parameter:

\begin{quote}
\begin{verbatim}
prop> \xs -> sort xs == sort (sort (xs::[Int]))
\end{verbatim}
\end{quote}

\noindent Since the right hand side of {\tt ->} is verbose as documentation,
open lambda terms are also allowed:

\begin{quote}
\begin{verbatim}
prop> sort xs == sort (sort (xs::[Int]))
\end{verbatim}
\end{quote}

\noindent To test properties in haddock annotations, we extended doctest to handle
them with QuickCheck.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Internal behavior}

TBD: talk about hspec.

\begin{quote}
\begin{verbatim}
TBD: Example
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integrating multiple test suites}

TBD: talk about Cabal.

\begin{quote}
\begin{verbatim}
TBD: Example
Test-Suite spec
  Main-Is: Spec.hs
  Type: exitcode-stdio-1.0
  ...

Test-Suite doctests
  Main-Is: doctests.hs
  Type: exitcode-stdio-1.0
  ...
\end{verbatim}
\end{quote}

\begin{quote}
\begin{verbatim}
TBD: Spec.hs comes here
\end{verbatim}
\end{quote}

\begin{quote}
\begin{verbatim}
TBD: doctest.hs comes here
\end{verbatim}
\end{quote}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Best current practice}

undefined.

The authors are not fundamentalist.
If functions to be defined are simple enough,
we might implement them first withtout signatures.
And their signatures can be automatically
inserted by IDE (like ghc-mod) later
if Haskell compilers can infer correctly.
Also, we can cut and paste typical examples and their results
from Haskell interpreters to their document.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{doctest}

how to handle error cases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{doctest and QuickCheck}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{hspec}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related work}

literate programming.

hunit.

test-framework.

smallCheck.

And others?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

\appendix

\section{Package Survey}

TBD

\section{Improving QuickCheck}

Since no-parameter properties has no parameters, it is enough to test them
just one.
However, QuickCheck 2.3 or earlier tests no-parameter properties 100 times.
More precisely, the evaluation results are memorized and they are
compared with {\tt True} 100 times.
This will be fixed in the next release of QuickCheck.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\acks

We would like to thank
Nick Smallbone for having improved QuickCheck so that no-parameter properties are tested just once.
We are grateful to David Waern and Simon Marlow
for introducing the property syntax to Haddock.


% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\end{document}
