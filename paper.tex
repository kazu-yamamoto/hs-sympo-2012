% vim: tw=70
%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{url}

\begin{document}

\conferenceinfo{Haskell Symposium 2012}{13th September, Copenhagen.}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{A draft paper to be submitted to Haskell Symposium 2012}
\preprintfooter{TBD: short description of paper}   % 'preprint' option specified.

\title{Behavior Driven Development in Haskell}
%\subtitle{Subtitle Text, if any}

\authorinfo{Simon HENGEL}
           {}
           {sol@typeful.net}
\authorinfo{Kazuhiko YAMAMOTO}
           {IIJ Innovation Institute Inc.}
           {kazu@iij.ad.jp}

\maketitle

\begin{abstract}

TBD: Asbtract will be written at the final moment.

State the problem.

Say why itâ€™s an interesting problem.

Say what your solution achieves.

Say what follows from your solution.

\end{abstract}

\category{D.2.2}{Software Engineering}{Testing tools}

\terms Languages, Design, Verification

\keywords Doctest, Haddock, Hspec, QuickCheck

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

\emph{IMPORTANT: @sol has to release a new version of hspec, that
includes the Specs-to-Spec and hspecX-to-hspec changes.  Otherwise the
code in this paper will not work!}

%%%% Describe the problem.

Haskell~\cite{haskell} has a very strong type system, which ensures that most type errors are
detected at compile time rather than runtime.  Thanks to this, we assume that
programs written in Haskell have less bugs than programs written in programming
languages that do not provide such a strong type system.

Unfortunately, the type system of Haskell does not always guarantee
correct semantics.
For example, it does not ensure that division by zero does not occur.
Another example is laws of type classes. 
For instance, the {\tt Monad} class has three Monad laws 
that its instance \emph{should} satisfy
but
it is the programmers responsibility to ensure that
instance definitions \emph{behave} as \emph{expected}.

Haskell programmers, however, is apt to rely on the type system too much
and tend not to write test code.
For example, Haskell Platform 2011.4.0.0 contains
TBD packages but TBD of them have no test code.
Lacking test code also means that typical usage examples are not provided.

We agree that type signatures are good abstract documentation~\cite{free}, but
there are many functions whose behavior cannot be guessed from their names and
type signatures.  One example is \verb|nub :: [a] -> [a]| from {\tt Data.List}.

In other programming language communities, behavior driven development
(BDD) is getting much attention, and is slowly replacing test driven
development (TDD).  TDD is an iterative style of software development
where the developer first writes a few test cases, then implements the
software in the simplest possible way which makes the test cases pass.
That could mean yielding a constant value at first.  Subsequently,
more test cases are written to reqire more details and drive the
implementation closer to the desired goal.  Rinse and repeat.  BDD
includes TDD, amongst other software development methodologies, but
with a terminology and mindset  shifted towards specification instead
of testing.  In BDD, specifications can be used for automatic testing.

In this paper, we explore how to apply BDD to Haskell.
For the purpose of this paper we only focus on the TDD aspect of BDD.

In BDD, all behavior should be documented, together with some
\emph{evidence} for that behavior.
For this purpose, 
we brought a test method from other programming language community and
extended missing features.
In particular, we introduced Doctest~\cite{doctest} and
integrated it with QuickCheck~\cite{quickcheck}
for user documentation.
For code documentation,
we make use of Hspec inspired by RSpec~\cite{rspec}
and we proposed some combinators to set expectations
about \emph{code example}\/s.

Automating such as test discovery and continuous integration (CI) ~\cite{ci} 
is an important aspect of BDD.
We improve CI suport for Doctest and Hspec.

Our contributions are:

\begin{itemize}
\item
    Implement Doctest in Haskell and add support for QuickCheck properties to Doctest (Section
    \ref{sec:user-doc} and Section \ref{sec:doctest})

\item
    Introduce a set of combinators to set expectations about
    code examples for use with Hspec. (Section \ref{sec:code-doc} and Section \ref{sec:hspec-comb})

\item
    Improve CI support for Doctest and Hspec (Section \ref{sec:TBD})

    TBD:
    \emph{This relates to hspec-discover and Doctest's Cabal support.}

\item
    Show best current practice of BDD in Haskell using Doctest and
    Hspec (Section \ref{ref:Best-current-practice})

\end{itemize}

\noindent Our BDD procedure
can be used for design, documentation and automatic testing.
We hope that this kill-three-birds-with-one-stone aspect
motivates Haskellers to write test code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terminology}

The definitions of words used in this paper is as follows:

\begin{description}

\item[developer]
    A programmer who develops a library.

\item[user]
    A programmer who uses a library.

\item[example]
    An example shows how a function is used.  It is either a \emph{code
    example} in the form of an HUnit test case; or an \emph{interactive
    example}, given as a short GHCi session.

\item[expectation]
    Expectations are used to define the expected outcome of a code
    example.  They serve the same purpose as \emph{assertion}\/s in xUnit
    testing frameworks, but use a different terminology.

\item[property]
    Property means a QuickCheck property as defined in
    \cite{quickcheck}.

\item[behavior]
    Behavior means an invariant of a function.  We use an informal description
    to refer to a particular behavior, e.g.  "sorts a list" or "launches
    missiles when run".

\item[evidence]
    Evidence is either an example or a property.  It provides some confidence,
    that a function exhibits a certain behavior.

\item[spec]
    TBD: BDD terminology for test suite.

\item[user documentation]
    Explanation of functions for users.
\item[code documentation]
    Explanation of functions for developers.

\end{description}

The word ``behavior'' is associated with imperative actions.
Since pure functions of Haskell are static,
this word might be improper for Haskell.
However, this word is already used in Haskell community~\cite{typeclassopedia}.
So, we use ``behavior'' instead of defining a new terminology in this paper.

%% \begin{quote}
%%     @kazu: We e.g. say ill-behaved Monoid instance.  So is
%%     ``behavior'' really a bad word?  But I agree that some people in
%%     the community might associated it with something imperative.

%%     One might also argue that ``should'' is not very mathematical, but
%%     it is common language when we talk about mathematics.  E.g. Brent
%%     Yorgey uses ``should'' a lot in the Typeclassopedia (e.g. ``\ldots
%%     {\tt Alternative} should satisfy the monoid laws\ldots'')
%% \end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}

In the Haskell community, HUnit and QuickCheck are commonly used %% what about SmallCheck?
and the {\tt test-framework} package integrates them.
We can categorize {\tt test-framework} as
a tool for TDD.
Before our work and Hspec, there was no widely used BDD tool for Haskell.

BDD tools used in other programming language communities are
mainly based on example tests,
and do not support property tests.
To our experience is, that it is not difficult to find properties for
pure Haskell functions.
So, when we bring BDD tools to
Haskell community, we should integrate them with properties test.

We can categorize evidence into two types: for users and
and for developers.
Evidence for users are those which are useful as user documentation.
By contrast, evidence for developers are
those which are not useful as user documentation
but should be written as code documentation.
A good example of evidence for developers
is a corner example registered in a bug tracking system.

BDD tools should be treat both of them and provide functionality
to extract evidence for users as user documentation.
If we can archive this, BDD tools can be used for
triple purpose: design, documentation and automatic testing.

\subsection{Doctest and Haddock}

A good candidate to describe evidence for users is Doctest in Python community.
It extends Python's documentation strings so that they
can contain examples.
Examples can be tested by the Python interpreter.

The standard documentation mechanism for Haskell is
Haddock~\cite{haddock}.
Haddock defines markup syntax in Haskell's comment.
Haddock provides markup for code blocks, indicated with ({\tt >}).
For example, the {\tt containers} packages has the following code block markup:

\begin{quote}
\small
\begin{verbatim}
-- | /O(1)/. Is the map empty?
--
-- > Data.Map.null (empty)           == True
-- > Data.Map.null (singleton 1 'a') == False

null :: Map k a -> Bool
null Tip      = True
null (Bin {}) = False
\end{verbatim}
\end{quote}

\noindent Though the code block itself is a useful feature,
we think this kind of usage has problems.
If the equations above are examples, we cannot distinguish
their results from their expression to be evaluated.
If they are properties, they should be distinguished
from example code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hspec}

If we have evidence that does not fit into the user documentation, but
would rather be part of a design document, we use Hspec.  Hspec
provides an EDSL for defining specs.  A spec organizes evidence in a
tree structure, and it is defined with \texttt{it} and
\texttt{describe}.

\begin{quote}
\small
\begin{verbatim}
import Test.Hspec.Monadic
spec :: Spec
spec = do
  describe "reverse" $ do
    it "reverses a list" $
      reverse [1 :: Int, 2, 3] @?= [3, 2, 1]

    it "gives the original list, if applied twice" $
      property $ \xs ->
        (reverse . reverse) xs == (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent The {\tt it} function combines a text description for a
behavior and a property or an example that gives some confidence in
that behavior into a spec.
Examples can be arbitrary HUnit assertions.  Properties must be of type {\tt
Property}; QuickCheck's \texttt{property} function can be used to turn
arbitrary properties into a \texttt{Property}.

The \texttt{describe} function combines a list of specs into a larger spec.  It
can be used to organize a spec as a tree.
Internally, a \texttt{Writer} is used to build up specs in a monadic way.

A spec can be run with the \texttt{hspec} function.  When a spec is
run, all properties and examples are evaluated, and failing properties
and examples are reported to the developer.

\begin{quote}
    TBD:
\begin{itemize}
    \item Motivate \verb|test-shouldbe|

        BDD frameworks use \emph{should} or \emph{must} instead of
        \emph{assert}.

        Here is an example that uses RSpec.

        \begin{verbatim}
23.should eq(23)
        \end{verbatim}

        RSpec provides a mechanism to expect exceptions.

        \begin{verbatim}
expect {launch_missiles}.to raise_error
        \end{verbatim}

        Hspec does not yet provide a mechanism to set expectations
        about the outcome of examples.  It uses HUnit assertions
        instead.

        HUnit does not provide a mechanism to expect exceptions.

    \item \emph{optional:} Motivate why it's important to integrate
        Doctest with
        Cabal.

    \item \emph{optional:} Motivate \verb|hspec-discover|

        It is common to have several files that contain \emph{specs}.
        And we want to be able to run them all together.  Hspec allows
        us combine specs together.  But this has to be done manually.
        Hspec does not provide a way to automatically discover and run
        all specs of a project.
\end{itemize}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Problem Summary}

Here is a summary of the problem:

\begin{itemize}
\item
    The Haskell community does not have common syntax to describe
    evidence with Haddock markup syntax.
\item
    The Haskell community does not have a BDD tool for user documentation.
\item
    Hspec does not provide combinators to express expectations with
    BDD terminology
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Solution}

To be able to specify evidence for users, we propose to add new
markup to Haddock and to use Doctest integrated with QuickCheck. To
describe evidence for developers, we propose to use Hspec also
integrated with QuickCheck.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{User documentation}
\label{sec:user-doc}

Evidence for users should be documented with Haddock markup syntax.
For this purpose, we propose the followings:

\begin{itemize}
\item Define a new Haddock markup for examples.
\item Define a new Haddock markup for properties.
\item Bring Doctest from the Python community to the Haskell
community and integrate it with QuickCheck.
\end{itemize}

%%%%%%%%%%%%%%%%
\subsubsection{Markup for Examples}

\noindent First, we introduce a new Haddock markup for the example.
In this paper, we use {\tt >>>} which is the same as Python's one.
Here is an example:

\begin{quote}
\small
\begin{verbatim}
>>> length []
0
\end{verbatim}
\end{quote}

\noindent The first line starts with {\tt >>>} and an expression follows. The second line contains its result. We can write this by copy-and-pasting from an interpreter and modifying the prompt.
It's worth explaining that we can specify operation sequences:

\begin{quote}
\small
\begin{verbatim}
>>> writeFile "tmpfile" "Hello"
>>> readFile "tmpfile"
"Hello"
\end{verbatim}
\end{quote}

\noindent Also, we can show exceptions.

\begin{quote}
\small
\begin{verbatim}
>>> head []
*** Exception: Prelude.head: empty list
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%
\subsubsection{Markup for Properties}

\noindent To specify properties, we also propose a new markup. In this paper, we
use the {\tt prop>} prefix. We can write properties which do not take
parameters as follows:

\begin{quote}
\small
\begin{verbatim}
prop> Data.Map.null empty == True
\end{verbatim}
\end{quote}

\noindent Of course, we allowed properties which take parameters by
using closed lambda terms.
Type signatures can be specified for each parameter:

\begin{quote}
\small
\begin{verbatim}
prop> \xs -> sort xs == sort (sort (xs::[Int]))
\end{verbatim}
\end{quote}

\noindent Since the right hand side of {\tt ->} is verbose as documentation,
lambda terms without the lambda prefix are also allowed:

\begin{quote}
\small
\begin{verbatim}
prop> sort xs == sort (sort (xs::[Int]))
\end{verbatim}
\end{quote}

\noindent Evidence in comments are automatically
tested by the Doctest command. We also provided a library
to do this job. Its implementation will discussed in Section~\ref{sec:doctest}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Code documentation}
\label{sec:code-doc}

We propose following extensions for Hspec to 
describe evidence for developers.

%%%%%%%%%%%%%%%%
\subsubsection{Setting expectations}

We propose several combinators, that can be used to set expectations
about the outcome of examples.  And we build them on top of
HUnit.

\begin{quote}\small\begin{verbatim}
type Expectation = Assertion
\end{verbatim}\end{quote}

\noindent A common expectation is, that a value should be equal to an other
value.

\begin{quote}\small\begin{verbatim}
x `shouldBe` 23
\end{verbatim}\end{quote}

\noindent This is just an other name for HUnit's \texttt{@?=}
operator.  The type is:

\begin{quote}\small\begin{verbatim}
shouldBe :: (Show a, Eq a) => a -> a -> Expectation
\end{verbatim}\end{quote}

\noindent Or we may expect that a value satisfies some predicate.

\begin{quote}\small\begin{verbatim}
x `shouldSatisfy` (< 23)
\end{verbatim}\end{quote}

\noindent The value is required to be in the \texttt{Show} class, so that a
useful error message can be given when the predicate is not satisfied.

\begin{quote}\small\begin{verbatim}
shouldSatisfy :: Show a => a -> (a -> Bool)
  -> Expectation
\end{verbatim}\end{quote}

\noindent Examples are often used to provide evidence for {\tt IO}
actions.

\begin{quote}\small\begin{verbatim}
launchMissiles >>=
  (`shouldBe` (Left "not implemented"))
\end{verbatim}\end{quote}

\noindent So we propose a shortcut for this common use case.

\begin{quote}\small\begin{verbatim}
launchMissiles `shouldReturn` (Left "not implemented")
\end{verbatim}\end{quote}

\begin{quote}\small\begin{verbatim}
shouldReturn :: (Show a, Eq a) => IO a -> a
  -> Expectation
\end{verbatim}\end{quote}

%%%%%%%%%%%%%%%%
\subsubsection{Expecting exceptions}

HUnit does not provide any versatile mechanism to state that an action
should throw an exception.  So we propose a combinator for that.

\begin{quote}\small\begin{verbatim}
shouldThrow :: Exception e => IO a -> (e -> Bool)
  -> Expectation
\end{verbatim}\end{quote}

\noindent It takes an {\tt IO} action, and a predicate.  The predicate
servers two purposes.  It selects the type of the expected exception,
and constraints the value.

\begin{quote}\small\begin{verbatim}
launchMissiles `shouldThrow` (== ExitFailure 1)
\end{verbatim}\end{quote}

\noindent To make it more convenient, to expect any exception of a
certain type, we provide type-restricted versions of {\tt (const
True)} for all standard exceptions.

\begin{quote}\small\begin{verbatim}
anyArithException :: ArithException -> Bool
anyArithException = const True
\end{verbatim}\end{quote}

\noindent Which can be used like so:

\begin{quote}\small\begin{verbatim}
let x = 1 `div` 0 in (x `seq` return x)
      `shouldThrow` anyArithException
\end{verbatim}\end{quote}


\begin{quote}
    TBD:
    \begin{itemize}
        \item
            This code snippet also illustrates how to deal with pure
            functions.
        \item
            {\tt seq} forces the exception.
        \item
            If {\tt x} is in {\tt NFData}, you may want to use {\tt
            deepseq} instead.
        \item
            The following would not work:
\begin{quote}\small\begin{verbatim}
(1 `div` 0) `shouldThrow` anyArithException
\end{verbatim}\end{quote}
        \item
            We think that pure functions that throw exceptions is bad
            API design.
    \end{itemize}
\end{quote}

TBD: Should we propose:
\begin{quote}\small\begin{verbatim}
shouldThrow_ :: (NFData a, Exception e) =>
  a -> (e -> Bool) -> Expectation
\end{verbatim}\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\emph{optional} Automatic discovery of specs}
TBD


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Haddock}

As we described, Haddock version 2.7.2 or earlier provides markup syntax for
code blocks, but does not provide any markup syntax for evidence.
We implemented markup support for examples ({\tt >>>}) and it is available in
Haddock version 2.8 or later.
We also extended Haddock to support markup for properties ({\tt prop>}) which
will be available with a future release of Haddock.
Both examples and properties in Haddock comments are pretty-printed when
generating documentation, (e.g. as HTML).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \subsection{QuickCheck}

%% \emph{TBD What does this have to do with the topic of the paper?}
%% \emph{Acknowledgment is enough.}

%% It is enough to test properties which do not have parameters just one.
%% However, QuickCheck 2.3 or earlier tests
%% properties which do not have parameters 100 times.
%% More precisely, the evaluation results are memorized and they are
%% compared with {\tt True} 100 times.
%% The current maintainer of QuickCheck modified so that
%% properties which do not have parameters
%% are tested just once in its source repository.
%% This feature will be available in the future release.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Doctest}
\label{sec:doctest}

\subsubsection{Testing examples}

TBD(@sol): how to obtain evidence from Haddock markup.
Old version uses Haddock API but now uses GHC API directly. Why?

TBD(@sol): escape from HUnit. Why?

TBD(@sol): Old version executes one GHCi for each function examples.
But new version executes one GHCI per module.
Drastic speed up. Do We need a graph for execution time?

Since test is done by comparing result string in Haddock notation
and result string from GHCi, exceptions can be handled.

\subsubsection{Testing properties}

To test properties, we also use GHCi.  Each property is enclosed
within ``\verb|quickCheck (|'' and ``\verb|)|'' string and GHCi
evaluates it.  Success or failures is decided according to result
string from GHCi.

If properties contain free variables, we need to add lambda
abstraction prefix before prepending the `quickCheck'' string.  To
check if properties contain free variables, we also use GHCi for easy
implementation at this moment.  GHCi reports free variables if found:

\begin{quote}
\small
\begin{verbatim}
Prelude Data.List> sort xs == sort (sort (xs::[Int]))
<interactive>:1:6: Not in scope: `xs'
<interactive>:1:24: Not in scope: `xs'
\end{verbatim}
\end{quote}

\noindent In this case, we should prepend the ``\verb|\xs -> |" string
to the property.

\begin{quote}
    TBD: describe the algorithm

    Below is the schematic algorithm, from my original mail to kazu.
    Can we somehow get rid of haskell-src, and hint, and only describe
    the algorithm?
\end{quote}


\noindent \verb|xs| is a free variable here.  So we would need to
close that term by transforming it to:

\begin{quote}\small\begin{verbatim}
\xs -> sort xs == sort (sort (xs::[Int]))
\end{verbatim}\end{quote}

\noindent I imagine this could work by performing those steps:

\begin{enumerate}

    \item
        parse the property with e.g. haskell-src (never used it, so
        I'm not sure if it allows you to parse code snippets)

    \item
        Load the module containing the DocProperty with hint, and try
        to look up all variables used by the property (\verb|sort| and
        \verb|xs| for the example above).

    \item
        Close the term over all variables, for which lookup failed,
        load it with hint and test it with quickCheck.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Hspec combinators for expectations}
\label{sec:hspec-comb}

TBD: describe the implementation of {\tt shouldBe}, etc.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Best current practice}
\label{ref:Best-current-practice}

This section show best current practice of
BDD in Haskell.

\begin{quote}
    \emph{TBD: one more example relating to IO is desired.}
\end{quote}

\subsection{Procedure of BDD}

\begin{quote}
@kazu: Can we use \verb|reverse| instead of \verb|rev| here?
\end{quote}

\begin{quote}
@sol: I used \verb|rev| just because it is short.
Actually I used \verb|reverse| once but it is overflowed
in the right hand side.
\end{quote}

First, we write a signature and leave the definition of the function undefined.

\begin{quote}
\small
\begin{verbatim}
rev :: [a] -> [a]
rev = undefined
\end{verbatim}
\end{quote}

\noindent Note that the {\tt placeholders} library provide better keyword such as {\tt notImplemented} and {\tt todo}.
Next we write user documentation in Haddock markup:

\begin{quote}
\small
\begin{verbatim}
-- |
-- 'rev' @xs@ returns the elements of @xs@
-- in reverse order. @xs@ must be finite.
--
-- >>> rev [1,2,3]
-- [3,2,1]
--
-- prop> rev [] == rev []
-- prop> rev (xs ++ ys) == rev ys ++ rev (xs::[Int])
-- prop> rev (rev xs) == (xs::[Int])

rev :: [a] -> [a]
rev = undefined
\end{verbatim}
\end{quote}

\noindent We should execute Doctest to ensure no syntax errors.
Also, we write code documentation with Hspec:

\begin{quote}
\small
\begin{verbatim}
describe "rev" $ do
  it "returns the first element in the last" $
    property $ \xs -> not (null xs) ==>
      head (rev xs) == last (xs :: [Int])

  it "returns the last element in the first" $
    property $ \xs -> not (null xs) ==>
      last (rev xs) == head (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent Also, we should execute this Hspec module
to ensure no syntax errors.
Then we implement the function.

\begin{quote}
\small
\begin{verbatim}
rev :: [a] -> [a]
rev = foldl (flip (:)) []
\end{verbatim}
\end{quote}

\noindent Now we run test suites until
all test failures disappear.

\begin{quote}
    TBD: @kazu: Do we need this to make our case?  I'm asking, because
    it will require some work to get the language right.

    Note that the authors are not fundamentalist.  If functions to be
    defined are simple enough, we might implement them first withtout
    signatures.  And their signatures can be automatically inserted by
    IDE (such as Emacs/vim with {\tt ghc-mod}) later if Haskell
    compilers can infer correctly.  Also, we can copy-and-paste
    examples and their results from Haskell interpreters to their
    Haddock markup.
\end{quote}

\subsection{Automatic discover of specs}

\begin{quote}
    \emph{should emphasize ``automatically discover tests''}
\end{quote}

\begin{quote}
\emph{This is optional, so we can skip it, if necessary.}
\end{quote}

\noindent We think the following are good conventions for organizing specs:
\begin{itemize}
    \item create a separate spec file for each source file
    \item append {\tt Spec.hs} to the name of spec files
\end{itemize}

\noindent If we have a source tree like so:

\begin{quote}
\small
\begin{verbatim}
src/Foo.hs
src/Foo/Bar.hs
src/Baz.hs
\end{verbatim}
\end{quote}

\noindent We would end up with the following spec files.

\begin{quote}
\small
\begin{verbatim}
test/FooSpec.hs
test/Foo/BarSpec.hs
test/BazSpec.hs
\end{verbatim}
\end{quote}

\begin{itemize}
\item We still want to combine those specs into a single spec.
\item By convention we put the combined spec into test/Spec.hs
\end{itemize}

\begin{quote}
\small
\begin{verbatim}
import Test.Hspec.Monadic

import qualified FooSpec
import qualified Foo.BarSpec
import qualified BazSpec

main :: IO ()
main = hspec $ do
  describe "Foo"     FooSpec.spec
  describe "Foo.Bar" Foo.BarSpec.spec
  describe "Baz"     BazSpec.spec
\end{verbatim}
\end{quote}

\begin{itemize}
\item We use a preprocessor (http://hackage.haskell.org/package/hspec-discover) to automatically generate this boilerplate.
\end{itemize}

\begin{quote}
\small
\begin{verbatim}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integrating multiple test suites}

\begin{itemize}

\item It is important that testing is automated, including running of test
    suites.  Where should we put this?
\end{itemize}

\noindent Cabals test feature can be used to automatically run tests~\cite{cabal}.  A cabal
file can contain multiple test suites, so it is possible to define test suites
for Doctest and Hspec in a single cabal file.

A driver for Hspec looks like so:

\begin{quote}
\small
\begin{verbatim}
-- file Spec.hs
import Test.Hspec.Monadic
main = hspec spec
\end{verbatim}
\end{quote}

\noindent And a corresponding Cabal test suite section like so:

\begin{quote}
\small
\begin{verbatim}
test-suite spec
  type:          exitcode-stdio-1.0
  main-is:       Spec.hs
  build-depends: base, hspec
\end{verbatim}
\end{quote}

\noindent A driver for Doctest looks like so:

\begin{quote}
\small
\begin{verbatim}
-- file doctests.hs
import Test.DocTest
main = doctest ["src/Main.hs"]
\end{verbatim}
\end{quote}

\noindent And a corresponding Cabal test suite section like so:

\begin{quote}
\small
\begin{verbatim}
test-suite doctests
  type:          exitcode-stdio-1.0
  main-is:       doctests.hs
  build-depends: base, doctest
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Open problems and related work}

SmallCheck~\cite{smallcheck} is a tool for
automatic exhaustive testing at a certain level.
Both Doctest and Hspec do not have support for SmallCheck
at this moment.

The {\tt test-framework} family is a TDD tool, 
which currently integrates HUnit, QuickCheck, SmallCheck, and Doctest.
Automatic test discovery based on prefixes of function name
and is implemented using Template Haskell~\cite{template-haskell}.
All examples and properties must be written in a single
source file.

\begin{itemize}
    \item The {\tt testpack} package provides a function that is
        similar in purpose to {\tt shouldThrow}.

        @kazu: Do you think we should discuss this; or is it safe to
        ignore.

        @sol: Let's add this.

\begin{quote}\small\begin{verbatim}
assertRaises :: (Show a, Exception e, Show e, Eq e) =>
  String -> e -> IO a -> IO ()
\end{verbatim}\end{quote}
        But it has several shortcomings:
        \begin{itemize}
            \item
                It only works for exceptions with an {\tt Eq}
                instance, but several standard exceptions (most
                prominently {\tt ErrorCall}) have no {\tt Eq}
                instance.
            \item
                It places an unnecessary {\tt Show} constraint on the
                result of the {\tt IO} action, further limiting it's
                applicability.
            \item
                It only allows to expect specific values; expecting
                any exception of a certain type is not possible.
        \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \section{Conclusion}

%% \appendix

%% \section{Package Survey}

%% TBD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\acks

We are grateful to David Waern, Haddock's maintainer, for reviewing our patches
and accepting our patches to Haddock.
We would like to thank
Nick Smallbone for having improved QuickCheck so that
properties which do not have parameters are tested just once.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{refs}

\end{document}
