%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{url}

\newcommand{\hspec}{Hspec}

\begin{document}

\conferenceinfo{Haskell Symposium 2012}{13th September, Copenhagen.}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{A draft paper to be submitted to Haskell Symposium 2012}
\preprintfooter{TBD: short description of paper}   % 'preprint' option specified.

\title{Behavior Driven Development in Haskell}
%\subtitle{Subtitle Text, if any}

\authorinfo{Simon HENGEL}
           {TBD: Affiliation}
           {TBD: Email}
\authorinfo{Trystan SPANGLER}
           {TBD: Affiliation}
           {TBD: Email}
\authorinfo{Kazuhiko YAMAMOTO}
           {IIJ Innovation Institute Inc.}
           {kazu@iij.ad.jp}

\maketitle

\begin{abstract}

TBD: Asbtract will be written at the final moment.

State the problem.

Say why itâ€™s an interesting problem.

Say what your solution achieves.

Say what follows from your solution.

\end{abstract}

\category{D.2.2}{Software Engineering}{Testing tools}

\terms Languages, Design, Verification

\keywords Haddock, QuickCheck, doctest, hspec

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

%%%% Describe the problem.

Haskell has a very strong type system, which ensures that most type errors are
detected at compile time rather than runtime.  Thanks to this, we assume that
programs written in Haskell have less bugs than programs written in programming
languages that do not provide such a strong type system.

Unfortunately, the strong type system of Haskell does not guarantee correct
semantic.

\begin{quote}
    \emph{TBD: What about dependent types and GHC's new features?}
\end{quote}

Haskell programmers, however, tend to rely on the type system too much.  They
tend to write less test code than programmers of other programming languages.

\begin{quote}
    \emph{we need evidence to support this.}
\end{quote}

This also means that typical usage examples cannot be found from test code.

We agree that type signatures are good abstract document

\begin{quote}
    \emph{Should we quote "Theorems for free!" by P. Wadler here?}
\end{quote}

but there are many
functions whose behaviors cannot be guessed from their names and type
signatures.

In other programming language communities,
behavior driven development (BDD) is getting much attention
slowly replacing test driven development (TDD).
In BDD, test code is written with specification terminology.
In other words, specification can be used for automatic testing.

In this paper, we consider how to put BDD into practice in Haskell.
We brought BDD methods from other programming language communities and
integrated them with a Haskell-original test method.
In particular, we introduced {\tt doctest}~\cite{doctest} and
integrated with QuickCheck~\cite{quickcheck}.
We also implemented {\tt hspec} inspired by rspec~\cite{rspec}
and integrated with QuickCheck.

The contribution of this paper is as follows:

\begin{itemize}
\item Introduced {\tt doctest} from Python community to Haskell community
and integrated it with QuickCheck
(Section \ref{sec:Visible-behavior} and Section \ref{sec:doctest})
\item Introduced {\tt hspec} from Ruby community to Haskell community and
integrated it with QuickCheck
(Section \ref{sec:Internal-behavior} and Section \ref{sec:hspec})
\item Show best current practice of behavior driven development in Haskell (Section \ref{ref:Best-current-practice})
\end{itemize}

\noindent Our {\tt doctest} implementation
can be used for design, documentation and automatic testing.
We hope that this kill-three-birds-with-one-stone aspect
motivates Haskellers to write test code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terminology}

The definitions of words used in this paper is as follows:

\begin{description}
\item[developer] programmers who develop libraries
\item[users] programmers who use libraries
%%\item[unit test] tests for individual programs or libraries.
\item[example] Typical usage of functions.
\item[property] Invariants which functions have.
\item[behavior] How do functions behave for users. Behavior can be shown by using both examples and properties.
\item[documentation] Explanation of functions.
\end{description}

TBD: behavior would not be a proper word since Haskell's pure
functions are very static.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problems}

In Haskell community, HUnit and QuickCheck are commonly used %% what about SmallCheck?
and the {\tt test-framework} package integrates them.
We can categorize the {\tt test-framework} package into
a tool of TDD.
Before our work, there is no BDD tool commonly used in Haskell community.

BDD tools used in other programming language communities are
mainly based on example test
and do not support property test.
To our experience, it is not difficult to find properties for
pure Haskell functions.
So, when we bring BDD tools to
Haskell community, we should integrate them with properties test.

We can categorize behaviors into two types: visible behaviors
and internal behaviors.
Visible behaviors are those which are useful for both developers and users.
By contrast, internal behaviors are those which are usefull only for developers.
A good example of internal behaviors
is behavior for a corner case registered in a bug track system.

BDD tools should be treat both of them and provide functionality
to disclose visible behaviors as documentation for users.
If we can archive this, BDD tools can be used for
triple purpose: design, documentation and automatic testing.

A good candidate for this is {\tt doctest} in Python community.
It extends Python's documentation strings so that they
can contain examples.
Examples can be tested by the Python interpreter.

The standard documentation mechanism for Haskell is
Haddock~\cite{haddock}.
Haddock defines annotation syntax in Haskell's comment.
Haddock provides code block annotations indicated with ({\tt >}).
For example, the {\tt container} packages has the following code block annotation:

\begin{quote}
\small
\begin{verbatim}
-- | /O(1)/. Is the map empty?
--
-- > Data.Map.null (empty)           == True
-- > Data.Map.null (singleton 1 'a') == False

null :: Map k a -> Bool
null Tip      = True
null (Bin {}) = False
\end{verbatim}
\end{quote}

TBD: code block cannot show results. properties should be distinguished from examples.

TBD: Haddock version 2.7.2 or earlier does not provide annotation syntax
for examples and properties.

Here are summary of the problems:

\begin{itemize}
\item Haskell community does not have common syntax to describe
behaviors in Haddock.
\item Haskell community does not have a BBD tool for visible behaviors.
\item Haskell community does not have a BBD tool for internal behaviors.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Solution}

To specify visible behavior, we propose to add two new annotation syntax to Haddock and to use {\tt doctest} integrated with QuickCheck. To describe internal behavior, we propose to use {\tt hspec} aslo integrated with QuickCheck.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Visible behavior}
\label{sec:Visible-behavior}

\begin{quote}
    @kazu: I think all behavior is user visible, in the way that the user can
    observe it when he uses the function.  Otherwise we would not be interested
    in that behavior at all.  What do you think about using \emph{Behavior as
    user documentation} and \emph{Behavior as code documentation} instead of
    visible/internal behavior?  Or can we come up with something else?
\end{quote}

Useful behavior should be documented in Haddock.
For this purpose, we propose the followings:

\begin{itemize}
\item Define a new Haddock annotation syntax for examples.
\item Define a new Haddock annotation syntax for properties.
\item Bring {\tt doctest} from the Python community to the Haskell
community and integrate it with QuickCheck.
\end{itemize}

First, we introduce a new Haddock annotation syntax for the example.
In this paper, we use {\tt >>>} which is the same as Python's one.
Here is an example:

\begin{quote}
\small
\begin{verbatim}
>>> length []
0
\end{verbatim}
\end{quote}

\noindent The first line starts with {\tt >>>} and an expression follows. The second line contains its result. We can write this by copy-and-pasting from an interpreter and modifying the prompt.
It's worth explaining that we can specify operation sequences:

\begin{quote}
\small
\begin{verbatim}
>>> writeFile "tmpfile" "Hello"
>>> readFile "tmpfile"
"Hello"
\end{verbatim}
\end{quote}

\noindent Also, we can show exceptions.

\begin{quote}
\small
\begin{verbatim}
>>> head []
*** Exception: Prelude.head: empty list
\end{verbatim}
\end{quote}

To specify properties in Haddock annotations, we also propose a new syntax. In this paper, we use the {\tt prop>} prefix. We can write the no-parameter equation as follows:

\begin{quote}
\small
\begin{verbatim}
prop> Data.Map.null empty == True
\end{verbatim}
\end{quote}

\noindent Of course, we allowed parameterized properties by
using closed lambda terms.
Type signatures can be specified for each parameter:

\begin{quote}
\small
\begin{verbatim}
prop> \xs -> sort xs == sort (sort (xs::[Int]))
\end{verbatim}
\end{quote}

\noindent Since the right hand side of {\tt ->} is verbose as documentation,
open lambda terms are also allowed:

\begin{quote}
\small
\begin{verbatim}
prop> sort xs == sort (sort (xs::[Int]))
\end{verbatim}
\end{quote}

Examples and properties in Haddock annotations are automatically
tested by the {\tt doctest} command. We also provided a library
to do this job. Its implementation will discussed in Section~\ref{sec:doctest}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Internal behavior}
\label{sec:Internal-behavior}

If we have some behavior that does not fit into the user documentation, but
would rather be part of a design document, we use \hspec{}.

\hspec{} provides an EDSL for defining specs.  A spec organizes behavior in a
tree structure, and it is defined with \texttt{it} and \texttt{describe}.

\begin{quote}
\small
\begin{verbatim}
import Test.Hspec.Monadic
spec :: Specs
spec = do
  describe "reverse" $ do
    it "reverses a list" $
      reverse [1 :: Int, 2, 3] @?= [3, 2, 1]

    it "gives the original list, if applied twice" $ property $
      \xs -> reverse (reverse xs) == (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent The {\tt it} function combines a text description for a behavior and
a property or an example that gives some confidence in that behavior into a
spec.
Examples can be arbitrary HUnit assertions.  Properties must be of type {\tt
Property}; QuickCheck's \texttt{property} function can be used to turn
arbitrary properties inot a \texttt{Property}.

The \texttt{describe} function combines a list of specs into a larger spec.  It
can be used to organize a spec as a tree.
Internally, a \texttt{Writer} is used to build up specs in a monadic way.

A spec can be run with the \texttt{hspecX} function.  When a spec is run, all
properties and examples are evaluated, and failing properties and examples are
reported to the user (FIXME: user does not fit our definition of \emph{user}
here!).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Haddock}

We implemented the {\tt >>>} syntax and it
is available in Haddock version 2.8 or later.
We also extended Haddock to support the {\tt prop>} syntax
which will be available in the future release.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{QuickCheck}

Since no-parameter properties have no parameters,
it is enough to test them just one.
However, QuickCheck 2.3 or earlier tests no-parameter properties 100 times.
More precisely, the evaluation results are memorized and they are
compared with {\tt True} 100 times.
The current maintainer of QuickCheck modified that
no-parameter properties are tested just once in its source repository.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{doctest}
\label{sec:doctest}

TBD(@sol): how to obtain examples and properties from Haddock annotations.
Old version uses Haddock API but now uses GHC API directly. Why?

TBD(@sol): escape from HUnit. Why?

TBD(@sol): Old version executes one GHCi for each function examples.
But new version executes one GHCI per module.
Drastic speed up. Do We need a graph for execution time?

Since test is done by comparing result string in Haddock notation
and result string from GHCi, exceptions can be handled.

To test properties, we also uses GHCi.
Each property is enclosed with
the ``\verb|quickCheck (|'' and ``\verb|)|'' string
and GHCi evaluates it.
Success or failures is decided according to result string from GHCi.

If properties contain free variables,
we need to add lambda abstraction prefix before prepending
the `quickCheck'' string.
To check if properties contain free variables,
we also use GHCi for easy implementation at this moment.
GHCi reports free variables if found:

\begin{quote}
\small
\begin{verbatim}
Prelude Data.List> sort xs == sort (sort (xs::[Int]))
<interactive>:1:6: Not in scope: `xs'
<interactive>:1:24: Not in scope: `xs'
\end{verbatim}
\end{quote}

\noindent In this case, we should prepend the ``\verb|\xs -> |" string
to the property.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{hspec}
\label{sec:hspec}

TBD.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Best current practice}
\label{ref:Best-current-practice}

This section show best current practice of
BDD in Haskell.

\subsection{Procedure of BBD}

First, we write a signature and leave the definition of the function undefined.

\begin{quote}
\small
\begin{verbatim}
rev :: [a] -> [a]
rev = undefined
\end{verbatim}
\end{quote}

\noindent Note that the placeholders library provide better keyword such as {\tt notImplemented} and {\tt todo}.
Next we write visible behaviors in Haddock annotation:

\begin{quote}
\small
\begin{verbatim}
-- |
-- 'rev' @xs@ returns the elements of @xs@
-- in rev order. @xs@ must be finite.
--
-- >>> rev [1,2,3]
-- [3,2,1]
--
-- prop> rev [] == rev []
-- prop> rev (xs ++ ys) == rev ys ++ rev (xs::[Int])
-- prop> rev (rev xs) == (xs::[Int])

rev :: [a] -> [a]
rev = undefined
\end{verbatim}
\end{quote}

\noindent We should execute {\tt doctest} to ensure no syntax errors.
Also, we specifies internal behaviors with {\tt hspec}:

\begin{quote}
\small
\begin{verbatim}
describe "rev" $ do
  it "returns the first element in the last" $
    property $ \xs -> not (null xs) ==>
      head (rev xs) == last (xs :: [Int])

  it "returns the last element in the first" $
    property $ \xs -> not (null xs) ==>
      last (rev xs) == head (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent Also, we should execute this hspec module
to ensure no syntax errors.
Then we implement the function.

\begin{quote}
\small
\begin{verbatim}
rev :: [a] -> [a]
rev = foldl (flip (:)) []
\end{verbatim}
\end{quote}

\noindent Now we run test suites until
all test failures disappear.

Note that the authors are not fundamentalist.
If functions to be defined are simple enough,
we might implement them first withtout signatures.
And their signatures can be automatically
inserted by IDE (such as ghc-mod) later
if Haskell compilers can infer correctly.
Also, we can cut and paste examples and their results
from Haskell interpreters to their Haddock annotations.

\subsection{Combining multiple specs}

\begin{quote}
\emph{This is optional, so we can skip it, if necessary.}
\end{quote}

\begin{itemize}
\item We create a spec file for each source file
\item By convention, spec files end in Spec.hs
\end{itemize}

\noindent If we have a source tree like so:

\begin{quote}
\small
\begin{verbatim}
src/Foo.hs
src/Foo/Bar.hs
src/Baz.hs
\end{verbatim}
\end{quote}

\noindent We would end up with the following spec files.

\begin{quote}
\small
\begin{verbatim}
test/FooSpec.hs
test/Foo/BarSpec.hs
test/BazSpec.hs
\end{verbatim}
\end{quote}

\begin{itemize}
\item We still want to combine those specs into a single spec.
\item By convention we put the combined spec into test/Spec.hs
\end{itemize}

\begin{quote}
\small
\begin{verbatim}
import Test.Hspec.Monadic

import qualified FooSpec
import qualified Foo.BarSpec
import qualified BazSpec

main :: IO ()
main = hspecX $ do
  describe "Foo"     FooSpec.spec
  describe "Foo.Bar" Foo.BarSpec.spec
  describe "Baz"     BazSpec.spec
\end{verbatim}
\end{quote}

\begin{itemize}
\item We use a preprocessor (http://hackage.haskell.org/package/hspec-discover) to automatically generate this boilerplate.
\end{itemize}

\begin{quote}
\small
\begin{verbatim}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integrating multiple test suites}

\begin{itemize}

\item @kazu: Can you add a reference to:
\url{http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites}
\item @kazu: should this subsection go into "best current practice"?

\item It is important that testing is automated, including running of test
    suites.  Where should we put this?
\end{itemize}

\noindent Cabals test feature can be used to automatically run tests.  A cabal
file can contain multiple test suites, so it is possible to define test suites
for Doctest and \hspec{} in a single cabal file.

A driver for Hspec looks like so:

\begin{quote}
\small
\begin{verbatim}
-- file Spec.hs
import Test.Hspec.Monadic
main = hspecX spec
\end{verbatim}
\end{quote}

\noindent And a corresponding Cabal test suite section like so:

\begin{quote}
\small
\begin{verbatim}
test-suite spec
  type:          exitcode-stdio-1.0
  main-is:       Spec.hs
  build-depends: base, hspec
\end{verbatim}
\end{quote}

\noindent A driver for Doctest looks like so:

\begin{quote}
\small
\begin{verbatim}
-- file doctests.hs
import Test.DocTest
main = doctest ["src/Main.hs"]
\end{verbatim}
\end{quote}

\noindent And a corresponding Cabal test suite section like so:

\begin{quote}
\small
\begin{verbatim}
test-suite doctests
  type:          exitcode-stdio-1.0
  main-is:       doctests.hs
  build-depends: base, doctest
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Open problems and related work}

literate programming.

hunit.

test-framework.

smallCheck.

And others?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

\appendix

\section{Package Survey}

TBD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\acks

We are grateful to David Waern, 
one of the Haddock maintainers, 
for reviewing two new syntax to Haddock.
We would like to thank
Nick Smallbone for having improved QuickCheck so that no-parameter properties are tested just once.


% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Claessen et al. 2000]{quickcheck}
Claessen K. and Hughes J.,
``QuickCheck: a lightweight tool for random testing of Haskell programs'',
ICFP '00 Proceedings of the fifth ACM SIGPLAN international conference on Functional programming,
pp 268 -- 279,
2000

\bibitem[Marlow et al. 2010]{haddock}
Marlow S. and Waern D.,
``Haddock User Guide'',
URL http://www.haskell.org/haddock/doc/html/,
2010

\bibitem[Python 2012]{doctest}
Python Software Foundation,
``Python documentation'',
URL http://docs.python.org/library/doctest.html,
2012

\bibitem[Chelimsky et al. 2010]{rspec}
Chelimsky D.,
Astels D., Dennis Z., Hellesoy A., Helmkamp B., and North D.,
``The RSpec Book: Behaviour-Driven
Development with RSpec, Cucumber, and Friends'',
2010
%% Hellesoy -- o/

\end{thebibliography}

\end{document}
