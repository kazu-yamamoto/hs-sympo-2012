%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}

\begin{document}

\conferenceinfo{Haskell Symposium 2012}{13th September, Copenhagen.}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{A draft paper to be submitted to Haskell Symposium 2012}
\preprintfooter{TBD: short description of paper}   % 'preprint' option specified.

\title{Behavior Driven Development in Haskell}
%\subtitle{Subtitle Text, if any}

\authorinfo{Simon HENGEL}
           {TBD: Affiliation}
           {TBD: Email}
\authorinfo{Trystan SPANGLER}
           {TBD: Affiliation}
           {TBD: Email}
\authorinfo{Kazuhiko YAMAMOTO}
           {IIJ Innovation Institute Inc.}
           {kazu@iij.ad.jp}

\maketitle

\begin{abstract}

TBD: Asbtract will be written at the final moment.

State the problem.

Say why itâ€™s an interesting problem.

Say what your solution achieves.

Say what follows from your solution.

\end{abstract}

\category{D.2.2}{Software Engineering}{Testing tools}

\terms Languages, Design, Verification

\keywords Haddock, QuickCheck, doctest, hspec

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

%%%% Describe the problem.

One of the best features of Haskell is its strong type system, 
which ensures no type errors in programs if they can be complied.
Thanks to this, it is said that programs written in Haskell have less bugs
than other programming languages which do not provide such strong type systems.

\begin{quote}
    \emph{Would we need evidence to support the claim that "Haskell programs have less bugs"?}
\end{quote}

Unfortunately, the strong type system of Haskell does not guarantee
no value errors.
Haskellers is, however, apt to rely on the strong type system too much.
They tend to write less test code than programmers of other
programming languages. 

\begin{quote}
    \emph{we need evidence to support this.}
\end{quote}

This also means that typical usage examples cannot be found from test code.
We agree that type signatures are good abstract document but
there are many functions whose behaviors cannot be guessed from
their names and type signatures.

Why do we dislike to write test code?
It is probably because writing test code is not fun.
To encourage Haskellers to write more test code
to detect value errors,
we need a scheme to make writing test code more interesting.

\begin{quote}
    \emph{We should explain what is BDD around here}
\end{quote}

For this purpose,
we brought design methods from other programming language communities and
integrated them with a Haskell-original test method.
In particular, we introduced {\tt doctest} and
integrated with QuickCheck. 
We also implemented {\tt hspec} with QuickCheck enabled.

In our method, design specification takes role of documentation for users and
is used as test cases by its developer. 
This method would motivate Haskellers
bacause it has a kill-three-birds-with-one-stone aspect.

%The purpose of this paper is to encourage Haskllers to write documentation, which can be used for testing, in their libraries.

%%%% State your contributions.

The contribution of this paper is as follows:

\begin{itemize}
\item Introduced {\tt doctest} from Python community to Haskell community
and integrated it with QuickCheck (Section XXX)
\item Introduced {\tt hspec} from Ruby community to Haskell community and
integrated it with QuickCheck (Section XXX)
\item Show best current practice of design/documentation/tests (Section XXX)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terminology}

The definitions of words used in this paper is as follows:

\begin{description}
\item[unit test] tests for individual programs or libraries.
\item[example] Typical usage of functions.
\item[property] Invariants which functions have.
\item[behavior] How do functions behave for users. Behavior can be shown by using both examples and properties.
\item[design] TBD
\item[documentation] Explanation of functions.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Observation}

We insist that examples and properties, which are useful for users, should be
documented.
So, let us first observe Haddock (version 2.7.2 or earlier), the documentation system of Haskell. 
Haddock defines annotation syntax in Haskell's comment.

Haddock provides code block annotations indicated with ({\tt >}).
For example, the {\tt container} packages has the following code block annotation:

\begin{quote}
\begin{verbatim}
-- | /O(1)/. Is the map empty?
--
-- > Data.Map.null (empty)           == True
-- > Data.Map.null (singleton 1 'a') == False

null :: Map k a -> Bool
null Tip      = True
null (Bin {}) = False
\end{verbatim}
\end{quote}

TBD: code block cannot show results. properties should be distinguished from examples.

TBD: Talk about test-framework. it integrates HUnit and QuickCheck but not 
suitable for design.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Solution}

To specify visible behavior, we propose to add two new annotation syntax to Haddock and to use {\tt doctest} integrated with QuickCheck. To describe internal behavior, we propose to use {\tt hspec} aslo integrated with QuickCheck.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Visible behavior}

Useful behavior should be documented in Haddock. 
For this purpose, we propose the followings:

\begin{itemize}
\item Define a new Haddock annotation syntax for examples.
\item Define a new Haddock annotation syntax for properties.
\item Bring {\tt doctest} from the Python community to the Haskell
community and integrate it with QuickCheck.
\end{itemize}

First, we introduce a new Haddock annotation syntax for the example.
In this paper, we use {\tt >>>} which is the same as Python's one.
Here is an example:

\begin{quote}
\begin{verbatim}
>>> length []
0
\end{verbatim}
\end{quote}

\noindent The first line starts with {\tt >>>} and an expression follows. The second line contains its result. We can write this by copy-and-pasting from an interpreter and modifying the prompt.
It's worth explaining that we can specify operation sequences:

\begin{quote}
\begin{verbatim}
>>> writeFile "tmpfile" "Hello"
>>> readFile "tmpfile"
"Hello"
\end{verbatim}
\end{quote}

\noindent Also, we can show exceptions.

\begin{quote}
\begin{verbatim}
>>> head []
*** Exception: Prelude.head: empty list
\end{verbatim}
\end{quote}

To specify properties in Haddock annotations, we also propose a new syntax. In this paper, we use the {\tt prop>} prefix. We can write the no-parameter equation as follows:

\begin{quote}
\begin{verbatim}
prop> Data.Map.null empty == True
\end{verbatim}
\end{quote}

\noindent Of course, we allowed parameterized properties by
using closed lambda terms.
Type signatures can be specified for each parameter:

\begin{quote}
\begin{verbatim}
prop> \xs -> sort xs == sort (sort (xs::[Int]))
\end{verbatim}
\end{quote}

\noindent Since the right hand side of {\tt ->} is verbose as documentation,
open lambda terms are also allowed:

\begin{quote}
\begin{verbatim}
prop> sort xs == sort (sort (xs::[Int]))
\end{verbatim}
\end{quote}

Examples and properties in Haddock annotations are automatically
tested by the {\tt doctest} command. We also provided a library
to do this job. Its implementation will discussed in Section XXX.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Internal behavior}

TBD: talk about hspec.

\begin{quote}
\begin{verbatim}
TBD: Example
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integrating multiple test suites}

TBD: talk about Cabal.

\begin{quote}
\begin{verbatim}
TBD: Example
Test-Suite spec
  Main-Is: Spec.hs
  Type: exitcode-stdio-1.0
  ...

Test-Suite doctests
  Main-Is: doctests.hs
  Type: exitcode-stdio-1.0
  ...
\end{verbatim}
\end{quote}

\begin{quote}
\begin{verbatim}
TBD: Spec.hs comes here
\end{verbatim}
\end{quote}

\begin{quote}
\begin{verbatim}
TBD: doctest.hs comes here
\end{verbatim}
\end{quote}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Haddock}

Haddock version 2.8 or later provides the {\tt >>>} syntax. 
We extended Haddock to support the {\tt prop>} syntax by ourselves
for proof of concept.
The maintainers of Haddock agreed to introduce 
the {\tt prop>} syntax and is now supporting it by their own.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{QuickCheck}

Since no-parameter properties has no parameters, 
it is enough to test them just one.
However, QuickCheck 2.3 or earlier tests no-parameter properties 100 times.
More precisely, the evaluation results are memorized and they are
compared with {\tt True} 100 times.
The current maintainer of QuickCheck modified that
no-parameter properties are tested just once in its source repository.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{doctest}

TBD(@sol): how to obtain examples and properties from Haddock annotations.
Old version uses Haddock API but now uses GHC API directly. Why?

TBD(@sol): escape from HUnit. Why?

TBD(@sol): Old version executes one GHCi for each function examples.
But new version executes one GHCI per module.
Drastic speed up. Do We need a graph for execution time?

TBD: how to handle error cases.

TBD: how to integrate QuickCheck.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{hspec}

TBD.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Best current practice}

First, we write a signature and leave the definition of the function undefined.

\begin{quote}
\begin{verbatim}
rev :: [a] -> [a]
rev = undefined
\end{verbatim}
\end{quote}

\noindent Note that the placeholders library provide better keyword such as {\tt notImplemented} and {\tt todo}. Next we wrote documentation.

\begin{quote}
\begin{verbatim}
-- |
-- 'rev' @xs@ returns the elements of @xs@
-- in rev order. @xs@ must be finite.
-- 
-- >>> rev [1,2,3]
-- [3,2,1]
--
-- prop> rev [] == rev []
-- prop> rev (xs ++ ys) == rev ys ++ rev (xs::[Int])
-- prop> rev (rev xs) == (xs::[Int])

rev :: [a] -> [a]
rev = undefined
\end{verbatim}
\end{quote}


\begin{figure*}
\begin{verbatim}
  describe "rev" $ do
    it "return the first element in the last" $ property $
        \xs -> not (null xs) ==> head (rev xs) == last (xs :: [Int])

    it "return the last element in the first" $ property $
        \xs -> not (null xs) ==> last (rev xs) == head (xs :: [Int])
\end{verbatim}
\end{figure*}

\noindent We should run test in order to find errors in Haddock annotation.
Then we implement the function.

\begin{quote}
\begin{verbatim}
-- |
-- 'rev' @xs@ returns the elements of @xs@
-- in rev order. @xs@ must be finite.
-- 
-- >>> rev [1,2,3]
-- [3,2,1]
--
-- prop> rev [] == rev []
-- prop> rev (xs ++ ys) == rev ys ++ rev (xs::[Int])
-- prop> rev (rev xs) == (xs::[Int])

rev :: [a] -> [a]
rev = foldl (flip (:)) []
\end{verbatim}
\end{quote}

\noindent And test.

The authors are not fundamentalist.
If functions to be defined are simple enough,
we might implement them first withtout signatures.
And their signatures can be automatically
inserted by IDE (like ghc-mod) later
if Haskell compilers can infer correctly.
Also, we can cut and paste typical examples and their results
from Haskell interpreters to their document.

\subsection{Combining multiple specs}

\begin{quote}
\emph{This is optional, so we can skip it, if necessary.}
\end{quote}

\begin{itemize}
\item We create a spec file for each source file
\item By convention, spec files end in Spec.hs
\end{itemize}

\noindent If we have a source tree like so:

\begin{quote}
\begin{verbatim}
src/Foo.hs
src/Foo/Bar.hs
src/Baz.hs
\end{verbatim}
\end{quote}

\noindent We would end up with the following spec files.

\begin{quote}
\begin{verbatim}
test/FooSpec.hs
test/Foo/BarSpec.hs
test/BazSpec.hs
\end{verbatim}
\end{quote}

\begin{itemize}
\item We still want to combine those specs into a single spec.
\item By convention we put the combined spec into test/Spec.hs
\end{itemize}

\begin{quote}
\begin{verbatim}
import Test.Hspec.Monadic

import qualified FooSpec
import qualified Foo.BarSpec
import qualified BazSpec

main :: IO ()
main = hspecX $ do
  describe "Foo"     FooSpec.spec
  describe "Foo.Bar" Foo.BarSpec.spec
  describe "Baz"     BazSpec.spec
\end{verbatim}
\end{quote}

\begin{itemize}
\item We use a preprocessor (http://hackage.haskell.org/package/hspec-discover) to automatically generate this boilerplate.
\end{itemize}

\begin{quote}
\begin{verbatim}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related work}

literate programming.

hunit.

test-framework.

smallCheck.

And others?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

\appendix

\section{Package Survey}

TBD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\acks

We are grateful to David Waern and Simon Marlow
for introducing two new syntax to Haddock.
We would like to thank
Nick Smallbone for having improved QuickCheck so that no-parameter properties are tested just once.


% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\end{document}
