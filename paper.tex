% vim: tw=70
%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{url}
\usepackage{alltt}

\begin{document}

%\conferenceinfo{Haskell Symposium 2012}{13th September, Copenhagen.}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

% These are ignored, unless 'preprint' option specified.
%\titlebanner{A draft paper to be submitted to Haskell Symposium 2012}
\preprintfooter{BDD in Haskell}

\title{Behavior Driven Development in Haskell}
%\subtitle{Subtitle Text, if any}

\authorinfo{Kazuhiko YAMAMOTO}
           {IIJ Innovation Institute Inc.}
           {kazu@iij.ad.jp}
\authorinfo{Simon HENGEL}
           {}
           {sol@typeful.net}
\authorinfo{Markus KLINIK}
           {Elektrobit Automotive GmbH}
           {markus.klinik@elektrobit.com}

\maketitle

\begin{abstract}
Several widely used Haskell libraries do not have tests.  Test code
assists developers in maintaining correctness when extending software,
and shows users how an API is supposed to be used.

We show how to do behavior-driven development in Haskell with two
tools: Doctest and Hspec.  Our approach can be used for design,
documentation and automated testing.  We hope that this motivates
Haskell programmers to write more and better tests.
\end{abstract}

\section{Best current practices}
\label{sec:best-current-practice}

In this section we show how to do BDD in Haskell, how to reuse pieces
of specification, and how to use Doctest and Hspec in combination with
Cabal's test feature.

\subsection{Applying BDD to Haskell: An Example}
\label{sec:bcp-example}
This section shows how behavior driven development works in practice,
by means of the Fibonacci function.  This is a very simple
example, but the method is also applicable to more complicated
situations where design decisions might not be as obvious as here.

We present a step-by-step refinement of a library, and a corresponding
spec.  Each line of code is only given once when introduced,
subsequent code fragments are incremental updates, import statements
are omitted.  Appendix
\ref{sec:appendix-code} contains the complete code of this section.

\subsubsection{Starting with a minimal implementation}

We start with the function's documentation, which gives a usage
example, together with the simplest possible implementation that makes
the example work.

\begin{quote}
\small
\begin{verbatim}
-- | Calculate Fibonacci numbers.
--
-- >>> fib 10
-- 55
fib :: Int -> Integer
fib = const 55
\end{verbatim}
\end{quote}

\noindent This first step might appear excessively trivial, but as of now we
already have made some choices with regard to the API of the library.
By giving a usage example, we were forced to think about which
arguments the function takes.  We can now run Doctest to verify that
the example works.

\begin{quote}
\small
\begin{verbatim}
$ doctest Fib.hs
Examples: 1  Tried: 1  Errors: 0  Failures: 0
\end{verbatim}
\end{quote}


\subsubsection{Getting it right}

Next, we add a specification that forces our function to actually
calculate Fibonacci numbers.
At this stage we do not worry about invalid input or performance.  We
are happy with an implementation that works for small non-negative
integers.

\begin{quote}
\small
\begin{verbatim}
newtype Small = Small Int
  deriving Show

instance Arbitrary Small where
  arbitrary = Small . (`mod` 10) <$> arbitrary

main = hspec spec

spec = do
  describe "fib" $ do
    it "calculates arbitrary Fibonacci numbers" $ do
      property $ \(Small n) ->
        fib n == fib (n + 2) - fib (n + 1)
\end{verbatim}
\end{quote}

\noindent This spec fails when run:

\begin{quote}
\small
\begin{verbatim}
$ runhaskell FibSpec.hs

fib
 - calculates arbitrary Fibonacci numbers FAILED [1]

1) fib calculates arbitrary Fibonacci numbers FAILED
*** Falsifiable (after 1 test):
Small 1

Finished in 0.0021 seconds

1 example, 1 failure
\end{verbatim}
\end{quote}

\noindent So we add a working implementation:

\begin{quote}
\small
\begin{verbatim}
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
\end{verbatim}
\end{quote}

\noindent Both Doctest and Hspec report success now.


\subsubsection{Making it fast}

Our implementation is quite inefficient, as made evident by this
specification:

\begin{quote}
\small
\begin{verbatim}
it "is efficient" $ do
  timeout 10000 (evaluate $ fib 32)
    `shouldReturn` Just 2178309
\end{verbatim}
\end{quote}

\noindent When we run it, hspec tells us:

\begin{quote}
\small
\begin{verbatim}
$ runhaskell FibSpec.hs

fib
 - calculates arbitrary Fibonacci numbers
 - is efficient FAILED [1]

1) fib is efficient FAILED
expected: Just 2178309
 but got: Nothing

Finished in 0.0685 seconds

2 examples, 1 failure
\end{verbatim}
\end{quote}

\noindent And we respond with an efficient implementation:

\begin{quote}
\small
\begin{verbatim}
fib :: Int -> Integer
fib n = fibs !! n
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
\end{verbatim}
\end{quote}

\noindent With a much more efficient implementation at hand, we can
now adapt our definition of small non-negative integers, so that
a wider range of input values is tested:

\begin{quote}
\small
\begin{verbatim}
instance Arbitrary Small where
  arbitrary = Small . (`mod` 1000) <$> arbitrary
\end{verbatim}
\end{quote}


\subsubsection{Handling invalid input}

We have an implementation of the Fibonacci function
that calculates correct values for all non-negative integers.
But what about negative ones? Let's assume that we want our
implementation to throw an exception in this case. We would
specify it like this.

\begin{quote}
\small
\begin{verbatim}
it "throws ErrorCall on negative input" $ do
  evaluate (fib (-10)) `shouldThrow` anyErrorCall
\end{verbatim}
\end{quote}

\noindent Our implementation already fulfils this spec, so we are
fine.

\subsubsection{Dealing with specification changes}

At some point, we realize that throwing an exception on invalid input
is not suitable for our use-case.  Hence, we change the specification,
so that negative input values should result in zero.

\begin{quote}
\small
\begin{verbatim}
it "returns 0 on negative input" $ do
  property $ \n -> n < 0 ==>
    fib n == 0
\end{verbatim}
\end{quote}

\noindent Now our specification fails, so we adapt the implementation
accordingly.

\begin{quote}
\small
\begin{verbatim}
fib n | n < 0     = 0
      | otherwise = fibs !! n
\end{verbatim}
\end{quote}

\noindent This concludes our example.  We have seen how to utilize
behavior driven development to incrementally build a small library.
We always extend or adapt the specification first, watch it fail,  and
then tighten the implementation.  The combinators {\tt shouldBe}, {\tt
shouldReturn} and {\tt shouldThrow} can be used to specify behavior of
functions in an intuitive, easy to read manner.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reusable pieces of specification}
\label{sec:reusable-specs}

RSpec provides an explicit mechanism to facilitate reuse of pieces of
specification~\cite{rspec}.
In Haskell we get reusability for free, it does not require any
explicit support from Hspec.
The following example illustrates this.
Here is a specification that documents that a list is a monoid:

\begin{quote}
\small
\begin{verbatim}
spec = do
  describe "List as a Monoid" $ do
    describe "mempty" $ do
      it "is a left identity" $ property $ \x ->
        mempty <> x == (x :: [Int])

      it "is a right identity" $ property $ \x ->
        x <> mempty == (x :: [Int])

    describe "<>" $ do
      it "is associative" $ property $ \x y z ->
        (x <> y) <> z == (x <> (y <> z) :: [Int])
\end{verbatim}
\end{quote}

\noindent It is possible to make this specification reusable, by
abstracting over the type:

\begin{quote}
\small
\begin{verbatim}
shouldSatisfyMonoidLaws ::
  (Eq a, Show a, Monoid a, Arbitrary a) => a -> Spec
shouldSatisfyMonoidLaws t = do
  describe "mempty" $ do
    it "is a left identity" $ property $ \x ->
      mempty <> x == x `asTypeOf` t

    it "is a right identity" $ property $ \x ->
      x <> mempty == x `asTypeOf` t

  describe "<>" $ do
    it "is associative" $ property $ \x y z ->
      (x <> y) <> z == x <> (y <> z) `asTypeOf` t
\end{verbatim}
\end{quote}

\noindent This can be used to document and test arbitrary Monoid
instances.
The specification from above becomes:

\begin{quote}
\small
\begin{verbatim}
spec = do
  describe "List as a Monoid" $ do
    shouldSatisfyMonoidLaws (undefined :: [Int])
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cabal integration}

\noindent Cabal's test feature can be used to automatically run tests~\cite{cabal}.  A cabal
file can contain multiple test suites, so it is possible to define test suites
for Doctest and Hspec in the same cabal file.

As discussed in Section~\ref{sec:solution-discovery},
{\tt hspec-discover} can be used to automatically generate a test
driver for Hspec:

\begin{quote}
\small
\begin{verbatim}
-- file Spec.hs
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
\end{verbatim}
\end{quote}

\noindent A corresponding Cabal test suite section looks like this:

\begin{quote}
\small
\begin{verbatim}
test-suite spec
  type:          exitcode-stdio-1.0
  main-is:       Spec.hs
  build-depends: base, hspec
\end{verbatim}
\end{quote}

\noindent Doctest provides both, an executable and a library.  The library
exposes a function ``{\tt doctest}'' of type:


\begin{quote}
\small
\begin{verbatim}
doctest :: [String] -> IO ()
\end{verbatim}
\end{quote}

\noindent Doctest's own {\tt main} is simply:
\begin{quote}
\small
\begin{verbatim}
main = getArgs >>= doctest
\end{verbatim}
\end{quote}



\noindent Consequently, it is possible to create a custom executable
for a project, by passing all command-line arguments that are required
for that project to {\tt doctest}.  A simple example looks like this:

\begin{quote}
\small
\begin{verbatim}
-- file doctests.hs
import Test.DocTest
main = doctest ["--optghc=isrc", "src/Main.hs"]
\end{verbatim}
\end{quote}

\noindent And a corresponding Cabal test suite section like this:

\begin{quote}
\small
\begin{verbatim}
test-suite doctests
  type:          exitcode-stdio-1.0
  main-is:       doctests.hs
  build-depends: base, doctest
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\section{The final code from Section~\ref{sec:bcp-example}}
\label{sec:appendix-code}

\begin{quote}
\small
\begin{verbatim}
-- file Fib.hs
module Fib (fib) where

-- | Calculate Fibonacci numbers.
--
-- >>> fib 10
-- 55
fib :: Int -> Integer
fib n | n < 0     = 0
      | otherwise = fibs !! n

fibs :: [Integer]
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)


-- file FibSpec.hs
module FibSpec (main, spec) where

import Control.Applicative
import Control.Exception
import System.Timeout

import Test.Hspec
import Test.QuickCheck

import Fib

-- small non-negative integers
newtype Small = Small Int
  deriving Show

instance Arbitrary Small where
  arbitrary = Small . (`mod` 1000) <$> arbitrary

main :: IO ()
main = hspec spec

spec :: Spec
spec = do
  describe "fib" $ do
    it "calculates arbitrary Fibonacci numbers" $ do
      property $ \(Small n) ->
        fib n == fib (n + 2) - fib (n + 1)

    it "is efficient" $ do
      timeout 10000 (evaluate $ fib 32)
        `shouldReturn` Just 2178309

    it "returns 0 on negative input" $ do
      property $ \n -> n < 0 ==>
        fib n == 0
\end{verbatim}
\end{quote}

\bibliographystyle{abbrvnat}
\bibliography{refs}

\end{document}
