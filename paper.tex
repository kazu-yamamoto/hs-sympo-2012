% vim: tw=70
%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{url}
\usepackage{alltt}

\begin{document}

\conferenceinfo{Haskell Symposium 2012}{13th September, Copenhagen.}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{A draft paper to be submitted to Haskell Symposium 2012}
\preprintfooter{TBD: short description of paper}   % 'preprint' option specified.

\title{Behavior Driven Development in Haskell}
%\subtitle{Subtitle Text, if any}

\authorinfo{Simon HENGEL}
           {}
           {sol@typeful.net}
\authorinfo{Kazuhiko YAMAMOTO}
           {IIJ Innovation Institute Inc.}
           {kazu@iij.ad.jp}

\maketitle

\begin{abstract}

Many Haskell programmers tend not to write test code even though the
strong type system of Haskell cannot always ensure correct semantics.
Test code helps users to understand the usage of
functions and developers to maintain semantics
while extending software. To ease the production and enhance the value of test code, we
propose to carry out behavior driven development with two tools:
Doctest integrated with QuickCheck for user documentation and Hspec
with combinators extended for developer documentation. With our
method, specification can be used for documentation and automatic
testing. This kill-three-birds-with-one-stone aspect would motivate
Haskellers to write test code.

%% State the problem.
%% Say why it's an interesting problem.
%% Say what your solution achieves.
%% Say what follows from your solution.

\end{abstract}

\category{D.2.2}{Software Engineering}{Testing tools}

\terms Languages, Design, Verification

\keywords Doctest, Haddock, Hspec, QuickCheck

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

%%%% Describe the problem.

Haskell~\cite{haskell} has a very strong type system, which ensures that most type errors are
detected at compile time rather than runtime.  Thanks to this, we assume that
programs written in Haskell have less bugs than programs written in programming
languages that do not provide such a strong type system.

Unfortunately, the type system of Haskell does not always guarantee
correct semantics.
For example, it does not ensure that division by zero does not occur.
Another example is laws of type classes.
For instance, the {\tt Monoid} class has three Monoid laws
that its instance \emph{should} satisfy
but
it is the programmers responsibility to ensure that
instance definitions \emph{behave} as \emph{expected}.

Haskell programmers, however, are apt to rely on the type system too
much and tend not to write test code.  For example, Haskell
Platform 2011.4.0.0 contains 23 packages, not counting the 19 core
libraries that come with GHC.  Only 8 of them have a test suite, 5
provide example code, and 10 have neither tests nor examples.
A lack of tests is not only a quality and maintainability issue.  It
also is a lack of documentation.  Tests document how code is supposed
to be used, and tests document the behavior of code.

We agree that type signatures are good abstract documentation~\cite{free}, but
there are many functions whose behavior cannot be guessed from their names and
type signatures.  One example is \verb|nub :: [a] -> [a]| from {\tt Data.List}.

In other programming language communities, behavior driven development
(BDD) is getting much attention, and is slowly replacing test driven
development (TDD).  TDD is an iterative style of software development
where the developer first writes a few test cases, then implements the
software in the simplest possible way which makes the test cases pass.
That could mean yielding a constant value at first.  Subsequently,
more test cases are written to require more details and drive the
implementation closer to the desired goal.  Rinse and repeat.  

BDD includes TDD, but with a terminology and mindset shifted towards
specification instead of testing. BDD also includes other software
development methods, such as automatic test discovery and continuous
integration~\cite{ci}.  In BDD, specifications can be used for
automatic testing.  BDD-style TDD has been pioneered by
RSpec~\cite{rspec}.  In this paper, we explore how to apply the TDD
aspect of BDD to Haskell.

In BDD, all behavior should be documented, together with some testable
\emph{evidence} for that behavior.  Most existing BDD tools use
\emph{code examples} as evidence for behavior.
Hspec, a BDD tool for Haskell inspired by RSpec, supports
both code examples and \emph{properties} as evidence.
It can verify examples and test properties, and it can create an
informal specification document from that.

\begin{quote}
    \emph{kazu: we should talk about Python's doctest,
    Haskell's doctest and Haddock here and put
    citation on them.}
\end{quote}


We made two observations:
\begin{enumerate}
    \item
        Parts of a specification can be useful as user documentation.
    \item
        Doctest, a tool inspired by a Python module with the same
        name~\cite{doctest}, already allows to verify
        \emph{interactive examples} in Haddock comments.
\end{enumerate}

\noindent Doctest is not commonly described as a BDD tool, but we
think it fits the picture.
We show how to use Doctest and Hspec in combination to design,
document and test Haskell code.

Both, Doctest and Hspec are missing some features.  So we extend them
as needed.  In particular, our contributions are:

\begin{itemize}
\item
    We originally implemented Haskell's version of Doctest\footnote{%
    http://hackage.haskell.org/package/doctest}, and extended
    Haddock's markup to support examples, back in 2010
\item
    Add support for QuickCheck properties to Doctest and
    extend Haddock markup to support properties
    (Section
    \ref{sec:user-doc} and Section \ref{sec:doctest})

\item
    Introduce a set of combinators to express expectations about
    code examples for use with Hspec (Section \ref{sec:code-doc} and Section \ref{sec:hspec-comb})

\item
    Improve CI support for Doctest and Hspec (Section \ref{sec:TBD})

    TBD:
    \emph{This relates to hspec-discover and Doctest's Cabal support.}

\item
    Show best current practice of BDD in Haskell, using Doctest and
    Hspec (Section \ref{ref:Best-current-practice})

\end{itemize}

\noindent Our BDD procedure
can be used for design, documentation and automatic testing.
We hope that this kill-three-birds-with-one-stone aspect
motivates Haskellers to write test code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terminology}

The definitions of words used in this paper is as follows:

\begin{description}

\item[example]
    An example shows how a function is used.  It is either a \emph{code
    example} in the form of an HUnit test case; or an \emph{interactive
    example}, given as a short GHCi session.

\item[expectation]
    Expectations are used to define the expected outcome of a code
    example.  They serve the same purpose as \emph{assertions} in xUnit
    testing frameworks, but use a different terminology.

\item[property]
    Property means a QuickCheck property as defined in
    \cite{quickcheck}.

\item[behavior]
    Behavior means an invariant of a function.  We use an informal description
    to refer to a particular behavior, e.g.  "sorts a list" or "launches
    missiles when run".

\item[evidence]
    Evidence provides some confidence, that a function exhibits a
    certain behavior.  In Haskell we use examples and properties as
    evidence.

\item[spec]
    TBD: BDD terminology for test suite.
\end{description}


\begin{quote}
    \emph{sol: Can we remove what follows?}

    \emph{kazu: I want to keep them for readability.}

    \emph{sol: For me it really depends on how often we use something.
    If we only use it once or twice, I'd try make it clear from the
    context what is meant.}
\end{quote}

\begin{description}
\item[developer]
    A programmer who develops a library.

\item[user]
    A programmer who uses a library.


\item[user documentation]
    Explanation of functions for users.
\item[code documentation]
    Explanation of functions for developers.

\item[non-quantified property]
    Property which does not take parameters.

\item[quantified property]
    Property which takes parameters.

\end{description}

The word ``behavior'' is associated with imperative actions.
Since pure functions of Haskell are static,
this word might be improper for Haskell.
However, this word is already used in Haskell community~\cite{typeclassopedia}.
So, we use ``behavior'' instead of defining a new terminology in this paper.

\begin{quote}
    sol: We e.g. say ill-behaved Monoid instance.  So is
    ``behavior'' really a ``bad'' word?  But I agree that some people in
    the community might associated it with something imperative.

    kazu: ``behavior'' sounded strange at least to me at the first time.
    We alreay supported this word with typeclassopedia. So, I think
    this paragraph is completed. Should we replace ``is associated'' with
    ``might be associated''?

    sol: @kazu, this was primarily meant for @mkl as reference.

    One might also argue that ``should'' is not very mathematical, but
    it is common language when we talk about mathematics.  E.g. Brent
    Yorgey uses both ``should'' and ``behave'' a lot in the
    Typeclassopedia (e.g. ``\ldots {\tt Alternative} should satisfy
    the monoid laws\ldots'')
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
\label{sec:problem}

BDD tools can be used to document the behavior of a system in a way that
is similar to a specification.  All facets of the system should be
described with evidence, including every possible corner case.

We think that some evidence is useful as user documentation.
But there is also evidence, that is not
useful as user documentation.  E.g. that a particular \texttt{Monoid}
instance is a monoid in the mathematical sense is self-evident.

We propose to use Doctest and Haddock for evidence that is useful as
user documentation, and Hspec for evidence that is not useful as user
documentation.  The following subsections discuss problems that we
have to solve before we can do this.

\subsection{Doctest and Haddock}

The standard documentation mechanism for Haskell is
Haddock~\cite{haddock}.
Haddock has markup support for code blocks, and they are widely used
to include properties and examples into documentation\footnote{
See e.g. the documentation of
{\tt containers},
{\tt filepath},
{\tt bytestring} or
{\tt text}}.
Here is an example from the {\tt filepath} package.

\begin{quote}
\small
\begin{verbatim}
-- | Does the given filename have an extension?
--
-- > null (takeExtension x) == not (hasExtension x)
hasExtension :: FilePath -> Bool
hasExtension = any isExtSeparator . takeFileName
\end{verbatim}
\end{quote}

\noindent Though code blocks in Haddock comments are a useful feature,
we still think that this particular usage has problems.  The code
block contains a property.  And it would be useful to have a tool that
automatically extracts and tests the property.
But writing such a tool is hard, because it is not easy to decide
whether the code block is a property, an example, or something else.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hspec}

If we have evidence that does not fit into the user documentation, but
would rather be part of a design document, we use Hspec\footnote{%
Hspec was originally implemented by Trystan Spangler, and is now
maintained and actively/further developed by one of the authors.}.

Hspec provides an EDSL for defining specs.  A spec organizes evidence
in a tree structure (or a forest, to be accurate), and it is defined
with \texttt{it} and \texttt{describe}.

\begin{quote}
\small
\begin{verbatim}
import Test.Hspec.Monadic
main :: IO ()
main = spec $ do
  describe "reverse" $ do
    it "reverses a list" $
      assertEqual "" [3, 2, 1] (reverse [1, 2, 3])

    it "gives the original list, if applied twice" $
      property $ \xs ->
        (reverse . reverse) xs == (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent The {\tt it} function combines a text description for a
behavior and some evidence into a spec.
Code examples can be arbitrary HUnit assertions.  Properties must be of type {\tt
Property}; QuickCheck's \texttt{property} function can be used to turn
arbitrary properties into a \texttt{Property}.

The \texttt{describe} function combines a list of specs into a larger spec.
It can be used to organize a spec as a tree.
Internally, a \texttt{Writer} is used to build up specs in a monadic way.

A spec can be run with the \texttt{hspec} function.  When a spec is
run, all evidence is tested.  Behavior with evidence that does not
hold is reported to the developer.

%%%%%%%%%%%%%%%%
\subsubsection{Hspec does not provide a mechanism for expectations}
BDD frameworks use \emph{should} or \emph{must} instead of
\emph{assert} to express expectations.  Here is an example that uses
RSpec.

\begin{quote}\small\begin{verbatim}
[1, 2, 3].reverse.should eq([3, 2, 1])
\end{verbatim}\end{quote}


\noindent Hspec does not yet provide a mechanism to express
\emph{expectations} with that terminology.  The developer has to use
HUnit assertions instead.

%%%%%%%%%%%%%%%%
\subsubsection{Hspec provides no mechanism to expect exceptions}
RSpec provides a mechanism to expect exceptions.

\begin{quote}\small\begin{verbatim}
expect {launch_missiles}.to raise_error
\end{verbatim}\end{quote}

\noindent Neither Hspec nor HUnit provide a convenient equivalent.


\begin{quote}
    TBD:
\begin{itemize}
    \item \emph{optional:} Motivate why it's important to integrate
        Doctest with
        Cabal.

    \item \emph{optional:} Motivate \verb|hspec-discover|

        It is common to have several files that contain \emph{specs}.
        And we want to be able to run them all together.  Hspec allows
        us combine specs together.  But this has to be done manually.
        Hspec does not provide a way to automatically discover and run
        all specs of a project.
\end{itemize}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Problem summary}


\begin{quote}
    TBD: sol: @kazu, can you update this?
\end{quote}

Here is a summary of the problem:

\begin{itemize}
\item
    The Haskell community does not have common syntax to describe
    evidence with Haddock markup syntax.
\item
    The Haskell community does not have a BDD tool for user documentation.
\item
    Hspec does not provide combinators to express expectations with
    BDD terminology.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Solution}

As we explained in Section \ref{sec:problem},
we use Doctest for user documentation and Hspec for code documentation.
The following subsections explain two new markups of Haddock
and evidence combinators for Hspec.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{User documentation}
\label{sec:user-doc}



Evidence for users should be documented with Haddock markup syntax.
For this purpose, we propose the followings:

\begin{itemize}
\item Define new Haddock markup for examples.
\item Define new Haddock markup for properties.
\item Bring Doctest from the Python community to the Haskell
community and integrate it with QuickCheck.
\end{itemize}

%%%%%%%%%%%%%%%%
\subsubsection{Markup for examples}

\begin{quote}
\begin{itemize}
    \item
        We already added markup support for interactive examples to
        Haddock, back in 2010; and Doctest can verify them.
    \item
        But it is not possible to use properties in Haddock comments
        and automatically test them.

    \emph{kazu: I guess that it's enough to describe this in the Implementation Section.}
\end{itemize}
\end{quote}

\noindent First, we introduce new Haddock markup for the example.
In this paper, we use {\tt >>>} which is the same as Python's one.
Here is an example:

\begin{quote}
\small
\begin{verbatim}
>>> length []
0
\end{verbatim}
\end{quote}

\noindent The first line starts with {\tt >>>} and an expression follows. The second line contains its result. We can write this by copy-and-pasting from an interpreter and modifying the prompt.
It's worth explaining that we can specify operation sequences:

\begin{quote}
\small
\begin{verbatim}
>>> writeFile "tmpfile" "Hello"
>>> readFile "tmpfile"
"Hello"
\end{verbatim}
\end{quote}

\noindent Also, we can show exceptions.

\begin{quote}
\small
\begin{verbatim}
>>> head []
*** Exception: Prelude.head: empty list
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%
\subsubsection{Markup for properties}

\noindent To specify properties, we also propose new markup. In this paper, we
use the {\tt prop>} prefix. We can write non-quantified properties as follows:

\begin{quote}
\small
\begin{verbatim}
prop> Data.Map.null empty == True
\end{verbatim}
\end{quote}

\noindent Of course, we allowed quantified properties by using closed
lambda terms.

\begin{quote}
\small
\begin{alltt}
prop> \verb|\|x -> null (takeExtension x) == \(\hookleftarrow\)
            not (hasExtension x)
\end{alltt}
\end{quote}

\noindent Type signatures can be specified for each parameter:

\begin{quote}
\small
\begin{verbatim}
prop> \xs -> sort xs == (sort . sort) (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent Since the right hand side of {\tt ->} is verbose as documentation,
lambda terms without the lambda prefix are also allowed:

\begin{quote}
\small
\begin{verbatim}
prop> sort xs == (sort . sort) (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent We call such properties \emph{implicitly quantified}.  The
given property is implicitly quantified over \verb|xs|.

Evidence in comments are automatically
tested by the Doctest command. We also provided a library
to do this job. Its implementation will discussed in Section~\ref{sec:doctest}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Code documentation}
\label{sec:code-doc}

We propose following extensions for Hspec to
describe evidence for developers.

%%%%%%%%%%%%%%%%
\subsubsection{Setting expectations}

We propose several combinators which can be used to express expectations
about the outcome of examples.  These are built on top of HUnit.

\begin{quote}\small\begin{verbatim}
type Expectation = Assertion
\end{verbatim}\end{quote}

\noindent A common expectation is, that a value should be equal to an other
value.

\begin{quote}\small\begin{verbatim}
x `shouldBe` 23
\end{verbatim}\end{quote}

\noindent This is just an other name for HUnit's \texttt{@?=}
operator.  The type is:

\begin{quote}\small\begin{verbatim}
shouldBe :: (Show a, Eq a) => a -> a -> Expectation
\end{verbatim}\end{quote}

\noindent Or we may expect that a value satisfies some predicate.

\begin{quote}\small\begin{verbatim}
x `shouldSatisfy` (< 23)
\end{verbatim}\end{quote}

\noindent The value is required to be in the \texttt{Show} class, so that a
useful error message can be given when the predicate is not satisfied.

\begin{quote}\small\begin{verbatim}
shouldSatisfy :: Show a => a -> (a -> Bool)
  -> Expectation
\end{verbatim}\end{quote}

\noindent Examples are often used to provide evidence for {\tt IO}
actions.

\begin{quote}\small\begin{verbatim}
launchMissiles >>=
  (`shouldBe` Left "not implemented")
\end{verbatim}\end{quote}

\noindent So we propose a shortcut for this common use case.

\begin{quote}\small\begin{verbatim}
launchMissiles `shouldReturn` Left "not implemented"
\end{verbatim}\end{quote}

\begin{quote}\small\begin{verbatim}
shouldReturn :: (Show a, Eq a) => IO a -> a
  -> Expectation
\end{verbatim}\end{quote}


%%%%%%%%%%%%%%%%
\subsubsection{Expecting exceptions}

HUnit does not provide any versatile mechanism to state that an action
should throw an exception.  So we propose a combinator for that.

\begin{quote}\small\begin{verbatim}
shouldThrow :: Exception e => IO a -> (e -> Bool)
  -> Expectation
\end{verbatim}\end{quote}

\noindent It takes an {\tt IO} action, and a predicate.  The predicate
servers two purposes.  It selects the type of the expected exception,
and constraints the value.

\begin{quote}\small\begin{verbatim}
launchMissiles `shouldThrow` (== ExitFailure 1)
\end{verbatim}\end{quote}

\noindent To make it more convenient, to expect any exception of a
certain type, we provide type-restricted versions of {\tt (const
True)} for all standard exceptions.

\begin{quote}\small\begin{verbatim}
anyArithException :: ArithException -> Bool
anyArithException = const True
\end{verbatim}\end{quote}

\noindent Which can be used like so:

\begin{quote}\small\begin{verbatim}
let x = 1 `div` 0 in (x `seq` return x)
      `shouldThrow` anyArithException
\end{verbatim}\end{quote}


\begin{quote}
    TBD:
    \begin{itemize}
        \item
            This code snippet also illustrates how to deal with pure
            functions.
        \item
            {\tt seq} forces the exception.
        \item
            If {\tt x} is in {\tt NFData}, you may want to use {\tt
            deepseq} instead.
        \item
            The following would not work:
\begin{quote}\small\begin{verbatim}
(1 `div` 0) `shouldThrow` anyArithException
\end{verbatim}\end{quote}
        \item
            We think that pure functions that throw exceptions is bad
            API design.
    \end{itemize}
\end{quote}

TBD: Should we propose:
\begin{quote}\small\begin{verbatim}
shouldThrow_ :: (NFData a, Exception e) =>
  a -> (e -> Bool) -> Expectation
\end{verbatim}\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\emph{optional} Automatic discovery of specs}
TBD


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Haddock}

Haddock version 2.7.2 or earlier provided markup syntax for
code blocks, but did not provide any markup syntax for evidence.
As we described, we implemented markup support for examples ({\tt >>>}) in 2010.
It is available in Haddock version 2.8 or later.
We also extended Haddock to support markup for properties ({\tt prop>}) which
will be available with a future release of Haddock.
Both examples and properties in Haddock comments are pretty-printed when
generating documentation, (e.g. as HTML).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \subsection{QuickCheck}

%% \emph{TBD What does this have to do with the topic of the paper?}
%% \emph{Acknowledgment is enough.}

%% It is enough to test non-quantified properties just one.
%% However, QuickCheck 2.3 or earlier tests
%% non-quantified properties 100 times.
%% More precisely, the evaluation results are memorized and they are
%% compared with {\tt True} 100 times.
%% The current maintainer of QuickCheck modified so that
%% non-quantified properties
%% are tested just once in its source repository.
%% This feature will be available in the future release.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Doctest}
\label{sec:doctest}

\subsubsection{Testing examples}

\begin{itemize}
    \item
        Doctest uses the GHC API to extract Haddock comments.
    \item
        It uses the GHC API directly, so that it can more easily
        support old GHC versions.  Each release of Haddock only
        supports the latest GHC version.
    \item
        Doctest use GHCi to verify examples.
    \item
        It reuses the same GHCi session for all examples.
    \item
        Examples from the same Haddock comment are grouped together,
        and share the same scope.
    \item
        The scope is cleared with \verb|:reload| before a new
        Example group is started.
    \item
\end{itemize}

Since test is done by comparing result string in Haddock notation and
result string from GHCi, exceptions can be handled.

\subsubsection{Testing properties}

\noindent QuickCheck and GHCi are used to test properties.  Before we
test a property, we bring the module that contains the Haddock comment
from which we extracted the property into scope.

Implicitly quantified properties need to be closed before they can be
tested.  This requires the following steps.
\begin{enumerate}
    \item
        Find all free variables of the property
    \item
        Try to lookup each free variable in the module context
    \item
        Close the property over all free variables, for which lookup
        failed
\end{enumerate}

\noindent Here is an example:

\begin{quote}\small\begin{verbatim}
sort xs == (sort . sort) (xs :: [Int]))
\end{verbatim}\end{quote}

\noindent Both \verb|xs| and \verb|sort| are free variables, but
\verb|sort| is bound by the module context.  So we need to close the
term over \verb|xs|.

\begin{quote}\small\begin{verbatim}
\xs -> sort xs == (sort . sort) (xs :: [Int])
\end{verbatim}\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Hspec combinators for expectations}
\label{sec:hspec-comb}

\noindent All combinators introduced in \ref{sec:code-doc} have been
implemented in the {\tt hspec-shouldbe} package\footnote{%
http://hackage.haskell.org/package/hspec-shouldbe};
and they will be incorporated into a future
release of Hspec.
The implementation is trivial, so we will not further discuss it.

\begin{quote}
    TBD: The implementation of \verb|shouldThrow| may still be
    interesting.  We can describe it, if we have time left.
\end{quote}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Best current practice}
\label{ref:Best-current-practice}

This section show best current practice of
BDD in Haskell.

\begin{quote}
    \emph{TBD: one more example relating to IO is desired.}
\end{quote}

\subsection{Procedure of BDD}

First, we write a signature and leave the definition of the function undefined.

\begin{quote}
\small
\begin{verbatim}
reverse :: [a] -> [a]
reverse = undefined
\end{verbatim}
\end{quote}

\noindent Note that the {\tt placeholders} library provides better keywords such as {\tt notImplemented} and {\tt todo} and they tells source locations when executed.
Next we write user documentation in Haddock markup:

\begin{quote}
\small
\begin{alltt}
-- |
-- 'reverse' @xs@ returns the elements of @xs@
-- in reverse order. @xs@ must be finite.
--
-- >>> reverse [1,2,3]
-- [3,2,1]
--
-- prop> reverse [] == reverse []
-- prop> reverse (xs ++ ys) == reverse ys ++ \(\hookleftarrow\)
                               reverse (xs::[Int])
-- prop> reverse (reverse xs) == (xs::[Int])

reverse :: [a] -> [a]
reverse = undefined
\end{alltt}
\end{quote}

\noindent We should execute Doctest to ensure no syntax errors.
Also, we write code documentation with Hspec:

\begin{quote}
\small
\begin{verbatim}
describe "reverse" $ do
  it "returns the first element in the last" $
    property $ \xs -> not (null xs) ==>
      head (reverse xs) == last (xs :: [Int])

  it "returns the last element in the first" $
    property $ \xs -> not (null xs) ==>
      last (reverse xs) == head (xs :: [Int])
\end{verbatim}
\end{quote}

\noindent Also, we should execute this Hspec module
to ensure no syntax errors.
Then we implement the function.

\begin{quote}
\small
\begin{verbatim}
reverse :: [a] -> [a]
reverse = foldl (flip (:)) []
\end{verbatim}
\end{quote}

\noindent Now we run test suites until
all test failures disappear.

\subsection{Automatic discover of specs}

\begin{quote}
    \emph{should emphasize ``automatically discover tests''}
\end{quote}

\begin{quote}
\emph{This is optional, so we can skip it, if necessary.}
\end{quote}

\noindent We think the following are good conventions for organizing specs:
\begin{itemize}
    \item create a separate spec file for each source file
    \item append {\tt Spec.hs} to the name of spec files
\end{itemize}

\noindent If we have a source tree like so:

\begin{quote}
\small
\begin{verbatim}
src/Foo.hs
src/Foo/Bar.hs
src/Baz.hs
\end{verbatim}
\end{quote}

\noindent We would end up with the following spec files.

\begin{quote}
\small
\begin{verbatim}
test/FooSpec.hs
test/Foo/BarSpec.hs
test/BazSpec.hs
\end{verbatim}
\end{quote}

\begin{itemize}
\item We still want to combine those specs into a single spec.
\item By convention we put the combined spec into test/Spec.hs
\end{itemize}

\begin{quote}
\small
\begin{verbatim}
import Test.Hspec.Monadic

import qualified FooSpec
import qualified Foo.BarSpec
import qualified BazSpec

main :: IO ()
main = hspec $ do
  describe "Foo"     FooSpec.spec
  describe "Foo.Bar" Foo.BarSpec.spec
  describe "Baz"     BazSpec.spec
\end{verbatim}
\end{quote}

\begin{itemize}
\item We use a preprocessor (the {\tt hspec-discover} package\footnote{%
http://hackage.haskell.org/package/hspec-discover}) to automatically generate this boilerplate.
\end{itemize}

\begin{quote}
\small
\begin{verbatim}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integrating multiple test suites}

\begin{itemize}

\item It is important that testing is automated, including running of test
    suites.  Where should we put this?
\end{itemize}

\noindent Cabals test feature can be used to automatically run tests~\cite{cabal}.  A cabal
file can contain multiple test suites, so it is possible to define test suites
for Doctest and Hspec in a single cabal file.

A driver for Hspec looks like so:

\begin{quote}
\small
\begin{verbatim}
-- file Spec.hs
import Test.Hspec.Monadic
main = hspec spec
\end{verbatim}
\end{quote}

\noindent And a corresponding Cabal test suite section like so:

\begin{quote}
\small
\begin{verbatim}
test-suite spec
  type:          exitcode-stdio-1.0
  main-is:       Spec.hs
  build-depends: base, hspec
\end{verbatim}
\end{quote}

\noindent A driver for Doctest looks like so:

\begin{quote}
\small
\begin{verbatim}
-- file doctests.hs
import Test.DocTest
main = doctest ["src/Main.hs"]
\end{verbatim}
\end{quote}

\noindent And a corresponding Cabal test suite section like so:

\begin{quote}
\small
\begin{verbatim}
test-suite doctests
  type:          exitcode-stdio-1.0
  main-is:       doctests.hs
  build-depends: base, doctest
\end{verbatim}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Open problems and future work}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reusable spec}

Reusable spec is an idea to scrap boilerplate of evidence.
For instance, without reusable spec,
each developer of an instance of a type class should
express evidence for its laws.
Since instances of a type class share API,
we can avoid such boilerplate.
The following is an example to implement
evidence for Monoid laws:

\begin{quote}
\small
\begin{verbatim}
shouldSatisfyMonoidLaws ::
  (Eq a, Show a, Monoid a, Arbitrary a) => a -> Specs
shouldSatisfyMonoidLaws t = do
  describe "mempty" $ do
    it "is a left identity" $ property $ \x ->
      mempty <> x == x `asTypeOf` t

    it "is a right identity" $ property $ \x ->
      x <> mempty == x `asTypeOf` t

  describe "<>" $ do
    it "is associative" $ property $ \x y z ->
      (x <> y) <> z == x <> (y <> z) `asTypeOf` t
\end{verbatim}
\end{quote}

\noindent This can be used for any instances of Monoid.
Here is an example to apply it to a list:

\begin{quote}
\small
\begin{verbatim}
describe "List as a Monoid" $
  shouldSatisfyMonoidLaws (undefined :: [Int])
\end{verbatim}
\end{quote}

\noindent We have already implemented this experimentally.
We should ensure the practicality of reusable spec and
prepare reusable spec to cover variety of type classes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Source locations for failing examples}

TBD:

We do not get source locations for failing tests. Doctest solves this.
For Hspec/QuickCheck/HUnit something like JHC's
\verb|SRCLOC_ANNOTATE|
pragma\footnote{%
http://repetae.net/computer/jhc/jhc.shtml} could help.

\begin{quote}
    sol: @kazu should we cite
    \url{http://repetae.net/computer/jhc/jhc.shtml}?
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{TBD}

\begin{itemize}
    \item \emph{optional}: Bridging the gap between HUnit and QuickCheck
    \item
        Feedback for failing QuickCheck properties is not always as
        useful as it could be -> combinators that use QuickCheck's
        Result type could help
    \item
        Are more high-lever approaches to BDD, akin to Ruby's
        Cucumber, applicable to Haskell? (Observation: Cucumber's
        approach is tightly tied to OO)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related work}

SmallCheck~\cite{smallcheck} is a tool for
automatic exhaustive testing at a certain level.
Both Doctest and Hspec do not have support for SmallCheck
at this moment.
\begin{itemize}
    \item
        \emph{sol: Hspec's mechanism for evidence is extensible.  It
        would be easy to add support for SmallCheck.}
\end{itemize}

The {\tt test-framework} family is a TDD tool,
which currently integrates HUnit, QuickCheck, SmallCheck, and Doctest.
Automatic test discovery based on prefixes of function name
and is implemented using Template Haskell~\cite{template-haskell}.
All examples and properties must be written in a single
source file.

\begin{quote}
    sol: I think you can have several files with tests, but you have
    to combine the test suites manually.
\end{quote}


\begin{itemize}
    \item The {\tt testpack} package provides a function that is
        similar in purpose to {\tt shouldThrow}.

        sol: Do you think we should discuss this; or is it safe to
        ignore.

        kazu: Let's add this.

\begin{quote}\small\begin{verbatim}
assertRaises :: (Show a, Exception e, Show e, Eq e) =>
  String -> e -> IO a -> IO ()
\end{verbatim}\end{quote}
        But it has several shortcomings:
        \begin{itemize}
            \item
                It only works for exceptions with an {\tt Eq}
                instance, but several standard exceptions (most
                prominently {\tt ErrorCall}) have no {\tt Eq}
                instance.
            \item
                It places an unnecessary {\tt Show} constraint on the
                result of the {\tt IO} action, further limiting it's
                applicability.
            \item
                It only allows to expect specific values; expecting
                any exception of a certain type is not possible.
        \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

\begin{quote}
    TBD

    sol: @kazu, can you work on this, if you have time.  I think an
    ``itemized'' list is better than text.  It's more flexible for
    now, and @mkl or @sol can do the final wording)
\end{quote}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\acks

We are grateful to David Waern, Haddock's maintainer for reviewing and
accepting our patches to Haddock.

We would like to thank
Nick Smallbone for having improved QuickCheck so that
non-quantified properties are tested just once.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{refs}

\end{document}
